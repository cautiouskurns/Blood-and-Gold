# Feature Spec: Basic Melee Attack Action

| Property | Value |
|----------|-------|
| **Feature ID** | 1.7 |
| **Status** | ðŸ”´ Planned |
| **Priority** | ðŸ”¥ Critical |
| **Estimated Time** | 2.5 hours |
| **Phase** | Phase 1: Combat Visuals & Basic Interaction |
| **Dependencies** | Task 1.5 (Click-to-Move with Path Preview) |

---

## 1. Purpose

### Why This Feature Exists

Combat is the heart of Blood & Gold. Without attacks, there is no tactical puzzle to solve - just units walking around. This feature introduces the core combat verb: attacking an adjacent enemy to deal damage. The attack resolution system (d20 + modifiers vs Defense) creates meaningful variance in outcomes, rewarding positioning and smart targeting while maintaining tactical tension.

### What It Enables

- Players can damage and kill enemy units
- Basic combat loop becomes playable (move â†’ attack â†’ end turn)
- Foundation for all future combat abilities that deal damage
- Floating damage numbers provide satisfying feedback
- Death/removal creates permanent consequences in battle
- Test whether "one fighter vs 3 bandits" feels good (Phase 1 milestone)

### Success Criteria

| Criterion | Measurement |
|-----------|-------------|
| Attack initiation | Can attack adjacent enemies (1 tile distance) |
| Roll resolution | d20 + attack bonus vs target Defense determines hit/miss |
| Damage application | Hit deals weapon damage, miss deals 0 |
| Visual feedback | Damage number floats up from target |
| HP update | Target's HP bar reflects damage taken |
| Death handling | Target removed from grid when HP â‰¤ 0 |

---

## 2. Design Pillar Alignment

| Pillar | How This Feature Supports It |
|--------|------------------------------|
| **Tactical Combat** | Attacks only work on adjacent enemies, forcing players to position carefully before engaging. Can't just spam attack from anywhere. |
| **Build & Command** | Attack resolution uses classic d20 system familiar to CRPG fans. Modifiers from stats/equipment create character build differentiation. |
| **Meaningful Choice** | Choosing WHO to attack matters - focus the leader or clear minions first? Attack the wounded or fresh enemy? Each choice has tactical implications. |
| **Character Progression** | Attack bonuses and damage come from character stats and equipment, making upgrades feel impactful. |

---

## 3. How It Works

### Overview

When a friendly unit is selected and adjacent to an enemy (within 1 tile in any direction including diagonals), the player can initiate a melee attack. The attack is resolved using the classic d20 system: roll d20, add the attacker's attack bonus, compare to target's Defense value. If the roll meets or exceeds Defense, the attack hits and deals damage.

Damage is calculated as weapon die + strength modifier (e.g., 1d8 + 2 for sword + STR 14). A floating damage number appears above the target, the HP bar updates, and if HP drops to 0 or below, the unit dies and is removed from the grid.

For the prototype, attacks are triggered by right-clicking an adjacent enemy while a friendly unit is selected. This avoids cluttering the UI with an "Attack" button and feels intuitive.

### User Flow

```
1. Player has a friendly unit selected (from Task 1.4)
2. Enemy unit is adjacent (1 tile away, any direction)
3. Player right-clicks the adjacent enemy
4. Attack roll calculated: d20 + attack bonus
5. Compare to target Defense value
6. If hit: Calculate damage, show damage number, update HP
7. If miss: Show "MISS" floating text
8. If target HP â‰¤ 0: Target dies, removed from grid
9. Attack action consumed (future: turn ends or can still move)
```

### Rules & Constraints

- **Adjacency Required**: Must be within 1 tile (including diagonals) to melee attack
- **Attack Roll**: d20 + STR modifier + skill bonus vs Defense
- **Defense Value**: 10 + DEX modifier + armor bonus
- **Damage Roll**: Weapon die + STR modifier (e.g., 1d8 + 2)
- **Critical Hit**: Natural 20 = double damage (future enhancement)
- **No Friendly Fire**: Cannot attack allied units
- **One Attack Per Turn**: Each unit can attack once per turn (future: turn system enforces)
- **Death at 0 HP**: Units with HP â‰¤ 0 are immediately removed

### Edge Cases

- **No adjacent enemies**: Right-click does nothing, no valid target
- **Enemy out of range**: Show "Out of Range" or no response
- **Target dies**: Remove from grid, update pathfinding occupied tiles
- **Attacker dies from AoO**: Future - attack of opportunity kills attacker first
- **Multiple adjacent enemies**: Player chooses which to attack via click
- **Clicking empty space**: No attack, treated as deselection (Task 1.4)
- **Clicking ally**: No attack, could select that ally instead

---

## 4. User Interaction

### Controls

| Input | Action |
|-------|--------|
| Left-click friendly unit | Select unit (Task 1.4) |
| Right-click adjacent enemy | Initiate melee attack on that enemy |
| Right-click non-adjacent enemy | Nothing (out of range) |
| Right-click empty tile | Nothing (no target) |
| Right-click ally | Nothing (no friendly fire) |

### Visual Feedback

| Event | Visual Response |
|-------|-----------------|
| Hover adjacent enemy | Enemy highlights red (attack target indicator) |
| Right-click enemy | Brief attack animation (future: weapon swing) |
| Attack hits | Red damage number floats up from target |
| Attack misses | "MISS" text floats up from target |
| Critical hit | Yellow/gold damage number, larger size (future) |
| Target takes damage | HP bar shrinks immediately |
| Target dies | Unit fades out and is removed |

### Audio Feedback (Future Polish)

- Attack initiated: Sword swing sound
- Hit landed: Impact/flesh sound
- Miss: Whoosh/air sound
- Critical hit: Louder, more dramatic impact
- Enemy death: Death grunt/thud

---

## 5. Visual Design

### Attack Target Indicator

```
When unit selected and adjacent to enemy:

    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
    â”‚   â”‚ E â”‚   â”‚   E = Enemy (red highlight on hover)
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚ P â”‚   â”‚   P = Player unit (selected)
    â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
    â”‚   â”‚   â”‚   â”‚
    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Enemy tile highlights red when hovered to indicate valid attack target
```

### Floating Damage Number

```
Damage number animation:

    Start: Above target center
         â†‘
    "12" â† Red text, bold
         â†‘
    Float up 50 pixels over 1 second
         â†‘
    Fade out at end

Miss animation:
    "MISS" â† Gray/white text
    Same float behavior
```

### Color Palette

| Element | Color | Hex | Usage |
|---------|-------|-----|-------|
| Attack target highlight | Red | #e74c3c | 30% opacity on hover |
| Damage number (hit) | Red | #e74c3c | 100% solid |
| Damage number (miss) | White/Gray | #bdc3c7 | 100% solid |
| Damage number (critical) | Gold | #f1c40f | Future enhancement |
| Death fade | N/A | N/A | Alpha 1.0 â†’ 0.0 over 0.5s |

### Specifications

| Property | Value | Rationale |
|----------|-------|-----------|
| Damage number font size | 24px bold | Readable at a glance |
| Float distance | 50 pixels up | Clear but not excessive |
| Float duration | 1 second | Quick but noticeable |
| Fade start | 0.7 seconds | Start fading before end |
| Death fade duration | 0.5 seconds | Quick removal, not jarring |

---

## 6. Technical Implementation

### Scene Structure

```
DamageNumber.tscn (NEW)
â”œâ”€â”€ DamageNumber (Node2D) [root]
â”‚   â””â”€â”€ Label (Label)
â”‚       - Custom font, size 24, bold
â”‚       - Centered alignment

Unit.tscn (MODIFIED)
â”œâ”€â”€ Unit (Node2D) [root]
â”‚   â”œâ”€â”€ Sprite2D [existing]
â”‚   â”œâ”€â”€ LetterLabel [existing]
â”‚   â”œâ”€â”€ HPBar [existing]
â”‚   â”œâ”€â”€ SelectionIndicator [existing]
â”‚   â””â”€â”€ ClickArea [existing]
â”‚       - Add input_event handling for right-click
```

### New Files

**scripts/combat/attack_resolver.gd**
```gdscript
## AttackResolver - Handles attack rolls and damage calculation
## Part of: Blood & Gold Prototype
## Spec: docs/features/1.7-basic-melee-attack.md
class_name AttackResolver
extends RefCounted

# ===== SIGNALS =====
signal attack_resolved(attacker: Unit, target: Unit, result: AttackResult)

# ===== ATTACK RESULT =====
class AttackResult:
    var hit: bool = false
    var damage: int = 0
    var roll: int = 0
    var total_attack: int = 0
    var target_defense: int = 0
    var is_critical: bool = false

# ===== PUBLIC API =====
static func resolve_attack(attacker: Unit, target: Unit) -> AttackResult:
    ## Roll attack and calculate damage
    var result = AttackResult.new()

    # Get attacker stats
    var attack_bonus = _get_attack_bonus(attacker)
    var damage_dice = _get_damage_dice(attacker)
    var damage_modifier = _get_damage_modifier(attacker)

    # Get target defense
    result.target_defense = _get_defense(target)

    # Roll attack
    result.roll = randi_range(1, 20)
    result.total_attack = result.roll + attack_bonus

    # Check for hit
    result.hit = result.total_attack >= result.target_defense

    # Natural 20 = critical (future: double damage)
    if result.roll == 20:
        result.is_critical = true
        result.hit = true

    # Calculate damage on hit
    if result.hit:
        result.damage = _roll_damage(damage_dice, damage_modifier)
        if result.is_critical:
            result.damage *= 2

    return result

static func is_adjacent(attacker: Unit, target: Unit) -> bool:
    ## Check if two units are adjacent (within 1 tile)
    var diff = target.grid_position - attacker.grid_position
    return abs(diff.x) <= 1 and abs(diff.y) <= 1 and diff != Vector2i.ZERO

# ===== INTERNAL HELPERS =====
static func _get_attack_bonus(unit: Unit) -> int:
    ## Get total attack bonus for a unit
    # Prototype: Hardcoded based on unit type
    match unit.unit_type:
        Unit.UnitType.PLAYER:
            return 4  # STR 14 (+2) + Skill (+2)
        Unit.UnitType.THORNE:
            return 5  # STR 16 (+3) + Skill (+2)
        Unit.UnitType.LYRA:
            return 5  # DEX 16 (+3) + Skill (+2)
        Unit.UnitType.MATTHIAS:
            return 2  # STR 10 (+0) + Skill (+2)
        Unit.UnitType.ENEMY:
            return 3  # Bandit
        Unit.UnitType.INFANTRY:
            return 3
        Unit.UnitType.ARCHER:
            return 3
        _:
            return 0

static func _get_defense(unit: Unit) -> int:
    ## Get defense value for a unit
    match unit.unit_type:
        Unit.UnitType.PLAYER:
            return 14  # 10 + DEX 12 (+1) + Chain Shirt (+3)
        Unit.UnitType.THORNE:
            return 16  # 10 + DEX 10 (+0) + Plate (+6)
        Unit.UnitType.LYRA:
            return 15  # 10 + DEX 16 (+3) + Leather (+2)
        Unit.UnitType.MATTHIAS:
            return 13  # 10 + DEX 10 (+0) + Chain Shirt (+3)
        Unit.UnitType.ENEMY:
            return 12  # Bandit
        Unit.UnitType.INFANTRY:
            return 13
        Unit.UnitType.ARCHER:
            return 11
        _:
            return 10

static func _get_damage_dice(unit: Unit) -> int:
    ## Get weapon damage die (e.g., 8 for 1d8)
    match unit.unit_type:
        Unit.UnitType.PLAYER:
            return 8  # Sword 1d8
        Unit.UnitType.THORNE:
            return 8  # Sword 1d8
        Unit.UnitType.LYRA:
            return 4  # Dagger 1d4
        Unit.UnitType.MATTHIAS:
            return 6  # Staff 1d6
        Unit.UnitType.ENEMY:
            return 6  # Bandit weapon 1d6
        _:
            return 6

static func _get_damage_modifier(unit: Unit) -> int:
    ## Get damage modifier (usually STR)
    match unit.unit_type:
        Unit.UnitType.PLAYER:
            return 2  # STR 14
        Unit.UnitType.THORNE:
            return 3  # STR 16
        Unit.UnitType.LYRA:
            return 3  # DEX 16 (finesse)
        Unit.UnitType.MATTHIAS:
            return 0  # STR 10
        Unit.UnitType.ENEMY:
            return 2  # Bandit STR
        _:
            return 0

static func _roll_damage(dice: int, modifier: int) -> int:
    ## Roll damage: 1d[dice] + modifier
    return randi_range(1, dice) + modifier
```

**scenes/ui/DamageNumber.tscn**
```
[gd_scene format=3]

[node name="DamageNumber" type="Node2D"]
script = "res://scripts/ui/damage_number.gd"

[node name="Label" type="Label" parent="."]
offset_left = -50
offset_top = -20
offset_right = 50
offset_bottom = 20
theme_override_colors/font_color = Color("#e74c3c")
theme_override_font_sizes/font_size = 24
horizontal_alignment = 1
vertical_alignment = 1
```

**scripts/ui/damage_number.gd**
```gdscript
## DamageNumber - Floating damage text that animates and fades
## Part of: Blood & Gold Prototype
## Spec: docs/features/1.7-basic-melee-attack.md
class_name DamageNumber
extends Node2D

# ===== CONSTANTS =====
const FLOAT_DISTANCE: float = 50.0
const FLOAT_DURATION: float = 1.0
const FADE_START: float = 0.7

const COLOR_DAMAGE: Color = Color("#e74c3c")  # Red
const COLOR_MISS: Color = Color("#bdc3c7")    # Gray
const COLOR_CRITICAL: Color = Color("#f1c40f") # Gold

# ===== NODE REFERENCES =====
@onready var label: Label = $Label

# ===== PUBLIC API =====
func show_damage(amount: int, is_critical: bool = false) -> void:
    ## Display damage number and animate
    label.text = str(amount)

    if is_critical:
        label.add_theme_color_override("font_color", COLOR_CRITICAL)
        label.add_theme_font_size_override("font_size", 32)
    else:
        label.add_theme_color_override("font_color", COLOR_DAMAGE)

    _animate()

func show_miss() -> void:
    ## Display miss text and animate
    label.text = "MISS"
    label.add_theme_color_override("font_color", COLOR_MISS)
    _animate()

# ===== INTERNAL =====
func _animate() -> void:
    ## Float up and fade out
    var tween = create_tween()
    tween.set_parallel(true)

    # Float up
    tween.tween_property(self, "position:y", position.y - FLOAT_DISTANCE, FLOAT_DURATION)

    # Fade out (start fading at FADE_START)
    tween.tween_property(self, "modulate:a", 0.0, FLOAT_DURATION - FADE_START).set_delay(FADE_START)

    # Remove when done
    tween.chain().tween_callback(queue_free)
```

### Script Modifications

**unit.gd (Add attack handling)**
```gdscript
# ===== SIGNALS (Add to existing) =====
signal attack_initiated(attacker: Unit, target: Unit)
signal attack_received(attacker: Unit, damage: int)

# ===== CONSTANTS (Add) =====
const DEATH_FADE_DURATION: float = 0.5

# ===== ATTACK HANDLING (New section) =====
func can_attack(target: Unit) -> bool:
    ## Check if this unit can attack the target
    if target == null or target == self:
        return false
    if not is_alive() or not target.is_alive():
        return false
    if not AttackResolver.is_adjacent(self, target):
        return false
    if target.is_friendly() == is_friendly():
        return false  # No friendly fire
    return true

func perform_attack(target: Unit) -> void:
    ## Execute an attack against the target
    if not can_attack(target):
        return

    attack_initiated.emit(self, target)

    # Resolve the attack
    var result = AttackResolver.resolve_attack(self, target)

    # Spawn damage number
    _spawn_damage_number(target, result)

    # Apply damage if hit
    if result.hit:
        target.take_damage(result.damage)

    print("[Unit] %s attacks %s: Roll %d + %d = %d vs DEF %d -> %s for %d damage" % [
        unit_name,
        target.unit_name,
        result.roll,
        result.total_attack - result.roll,
        result.total_attack,
        result.target_defense,
        "HIT" if result.hit else "MISS",
        result.damage
    ])

func _spawn_damage_number(target: Unit, result: AttackResolver.AttackResult) -> void:
    ## Create floating damage number at target
    var damage_scene = preload("res://scenes/ui/DamageNumber.tscn")
    var damage_number = damage_scene.instantiate() as DamageNumber

    # Position above target
    damage_number.global_position = target.global_position + Vector2(0, -30)

    # Add to scene tree (use parent of target so it's in world space)
    target.get_parent().add_child(damage_number)

    # Display appropriate text
    if result.hit:
        damage_number.show_damage(result.damage, result.is_critical)
    else:
        damage_number.show_miss()

# ===== MODIFY _die() =====
func _die() -> void:
    ## Handle unit death with fade animation
    unit_died.emit(self)

    # Fade out animation
    var tween = create_tween()
    tween.tween_property(self, "modulate:a", 0.0, DEATH_FADE_DURATION)
    tween.tween_callback(queue_free)
```

**combat_manager.gd (Add attack handling)**
```gdscript
# ===== SIGNALS (Add) =====
signal attack_executed(attacker: Unit, target: Unit, hit: bool, damage: int)

# ===== ATTACK API (New section) =====
func attempt_attack(attacker: Unit, target: Unit) -> bool:
    ## Attempt to attack a target, return true if attack executed
    if attacker == null or target == null:
        return false

    if not attacker.can_attack(target):
        print("[CombatManager] Invalid attack: %s cannot attack %s" % [
            attacker.unit_name if attacker else "null",
            target.unit_name if target else "null"
        ])
        return false

    # Execute the attack
    attacker.perform_attack(target)

    return true
```

**main.gd (Add right-click handling)**
```gdscript
# In _unhandled_input, add right-click handling:
func _unhandled_input(event: InputEvent) -> void:
    # ... existing code ...

    ## Handle right-click for attack (Task 1.7)
    if event is InputEventMouseButton:
        if event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
            _handle_attack_click()

func _handle_attack_click() -> void:
    ## Handle right-click to attack adjacent enemy
    var selected = CombatManager.get_selected_unit()
    if selected == null:
        return

    var mouse_pos = get_global_mouse_position()
    var grid_pos = combat_grid.world_to_grid(mouse_pos)

    # Find unit at clicked position
    var target = get_unit_at_grid_pos(grid_pos)
    if target == null:
        return

    # Attempt attack
    CombatManager.attempt_attack(selected, target)
```

### Integration Points

| System | Integration |
|--------|-------------|
| Selection (Task 1.4) | Attack requires a selected unit |
| Movement (Task 1.5) | Positioning determines attack adjacency |
| HP System (Task 1.3) | Damage updates HP bar |
| Turn System (Task 1.8) | Attack consumes action for turn |
| Enemy AI (Task 2.14) | Enemies will use same attack system |
| Victory/Defeat (Task 1.9) | Deaths trigger win/lose checks |

### Signals

```gdscript
# In Unit
signal attack_initiated(attacker: Unit, target: Unit)
signal attack_received(attacker: Unit, damage: int)

# In CombatManager
signal attack_executed(attacker: Unit, target: Unit, hit: bool, damage: int)
```

---

## 7. File Structure

```
scripts/
â””â”€â”€ combat/
    â”œâ”€â”€ attack_resolver.gd     # NEW - Attack roll and damage calculation
    â”œâ”€â”€ unit.gd                # MODIFIED - Attack execution, death animation
    â””â”€â”€ ...

scripts/
â””â”€â”€ ui/
    â””â”€â”€ damage_number.gd       # NEW - Floating damage text

scenes/
â””â”€â”€ ui/
    â””â”€â”€ DamageNumber.tscn      # NEW - Damage number scene

scripts/
â””â”€â”€ autoload/
    â””â”€â”€ combat_manager.gd      # MODIFIED - Attack API

scripts/
â””â”€â”€ main/
    â””â”€â”€ main.gd                # MODIFIED - Right-click attack handling
```

---

## 8. Acceptance Criteria

Feature is complete when:

- [ ] Right-clicking adjacent enemy initiates attack
- [ ] Attack roll uses d20 + attack bonus vs Defense
- [ ] Hit attacks deal weapon damage + STR modifier
- [ ] Miss attacks deal 0 damage
- [ ] Damage number appears above target (red for damage, gray for miss)
- [ ] Damage number floats up 50 pixels over 1 second
- [ ] Target HP bar updates immediately on damage
- [ ] Target with HP â‰¤ 0 fades out and is removed
- [ ] Cannot attack non-adjacent enemies (no response)
- [ ] Cannot attack friendly units (no response)
- [ ] Cannot attack while moving (blocked during movement)
- [ ] Attack logged to console with roll details

---

## 9. Testing Checklist

### Functional Tests

- [ ] Player unit can attack adjacent bandit
- [ ] Attack roll calculated correctly (d20 + 4 for Player)
- [ ] Bandit defense is 12 (verified in roll)
- [ ] Hit damage is 1d8 + 2 (range 3-10)
- [ ] Killing blow removes enemy from grid
- [ ] Killed enemy no longer blocks pathfinding
- [ ] Cannot attack diagonally-adjacent enemy? (Should be able to - 1 tile includes diagonals)

### Visual Tests

- [ ] Damage number appears at correct position (above target)
- [ ] Damage number is red color (#e74c3c)
- [ ] "MISS" text is gray/white
- [ ] Float animation smooth (50px over 1s)
- [ ] Fade animation smooth (starts at 0.7s)
- [ ] Death fade animation smooth (0.5s)
- [ ] HP bar updates match damage dealt

### Edge Case Tests

- [ ] Clicking enemy 2+ tiles away: No attack
- [ ] Clicking ally: No attack
- [ ] Clicking empty tile: No attack
- [ ] Attack while unit moving: Blocked
- [ ] Attack already dead unit: Should not be possible (removed)
- [ ] Attack with no unit selected: Nothing happens
- [ ] Multiple attacks in quick succession: Each resolves properly

### Integration Tests

- [ ] Movement (Task 1.5) then attack works in sequence
- [ ] Selection indicator (Task 1.4) visible during attack targeting
- [ ] Enemy death updates unit count for victory check (Task 1.9)
- [ ] HP bar (Task 1.3) reflects damage correctly

### Console Output Tests

- [ ] Attack roll details printed: "[Unit] Player attacks Bandit: Roll 15 + 4 = 19 vs DEF 12 -> HIT for 7 damage"
- [ ] Miss output: "[Unit] Player attacks Bandit: Roll 3 + 4 = 7 vs DEF 12 -> MISS for 0 damage"

---

## 10. Implementation Notes

### Approach Rationale

**Why right-click for attack?**
- Intuitive for RTS/CRPG players
- Avoids need for "Attack" button in UI
- Keeps left-click for movement
- Can add Attack button later for accessibility

**Why separate AttackResolver class?**
- Encapsulates all attack math
- Reusable for enemy AI attacks
- Easy to unit test
- Single responsibility

**Why static methods in AttackResolver?**
- No state to maintain
- Pure functions (input â†’ output)
- Easy to call from anywhere

**Why hardcoded stats for prototype?**
- No stat/equipment system yet
- Values from GDD already defined
- Easy to replace with data-driven later

### Gotchas to Watch

1. **Damage number scene path**: Must match exactly when preloading
2. **Damage number parenting**: Add to target's parent, not target itself (target might queue_free)
3. **Death timing**: Fade animation must complete before queue_free
4. **Attack adjacency**: Diagonal = 1 tile, not 2 (include diagonals in adjacency check)
5. **Random seeding**: Godot handles this, but ensure randi_range works as expected

### Future Considerations

- **Critical hits**: Natural 20 = double damage (implement in AttackResolver)
- **Ranged attacks**: Task 2.7 - will use same AttackResolver but skip adjacency check
- **Attack of opportunity**: Task 2.13 - moving away triggers free attack
- **Abilities**: Tasks 2.3-2.6 - abilities will call AttackResolver with modified parameters
- **Status effects**: Bleeding, poison will modify damage over time

---

## 11. Definition of Done

- [ ] `attack_resolver.gd` created with roll/damage logic
- [ ] `DamageNumber.tscn` and `damage_number.gd` created
- [ ] `unit.gd` updated with attack execution
- [ ] `combat_manager.gd` updated with attack API
- [ ] `main.gd` updated with right-click handling
- [ ] Attack resolves correctly (hit/miss based on roll)
- [ ] Damage numbers display correctly
- [ ] Death animation and removal works
- [ ] All acceptance criteria pass
- [ ] Code follows GDScript style guidelines
- [ ] Ready for Task 1.8 (Turn System Framework)

---

## 12. References

### From GDD

- **Attack Roll**: "d20 + STR/DEX modifier + Skill rank" (Section 3)
- **Defense Value**: "10 + DEX modifier + Armor bonus" (Section 3)
- **Player STR**: 14 (+2 modifier) (Section 4)
- **Bandit Defense**: 12 (Section 4)
- **Sword Damage**: 1d8 (Section 4)
- **Critical Hit**: "Natural 20 = double damage" (Section 3)

### From Roadmap

- **Task 1.7**: Basic Melee Attack Action (Phase 1, 2.5 hours)
- **Dependencies**: Task 1.5 (movement for positioning)
- **Leads to**: Task 1.8 (Turn System), Task 1.9 (Victory/Defeat)

### Godot Documentation

- [randi_range](https://docs.godotengine.org/en/stable/classes/class_@globalscope.html#class-globalscope-method-randi-range)
- [Tween](https://docs.godotengine.org/en/stable/classes/class_tween.html)
- [Label](https://docs.godotengine.org/en/stable/classes/class_label.html)
