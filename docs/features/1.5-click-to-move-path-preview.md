# Feature Spec: Click-to-Move with Path Preview

| Property | Value |
|----------|-------|
| **Feature ID** | 1.5 |
| **Status** | ✅ Implemented |
| **Priority** | Critical |
| **Estimated Time** | 3 hours |
| **Phase** | Phase 1: Combat Visuals & Basic Interaction |
| **Dependencies** | Task 1.4 (Click-to-Select Unit) |

---

## 1. Purpose

### Why This Feature Exists

Movement is the core verb of tactical combat. Without the ability to move units, there is no positioning, no flanking, no tactical decision-making. This feature transforms the static grid into a dynamic battlefield where players can maneuver their units. The path preview ensures players understand movement costs and can plan their positioning before committing, which is essential for the **Tactical Combat** design pillar.

### What It Enables

- Players can reposition units strategically on the battlefield
- Visual feedback shows exactly where a unit can and cannot move
- Path preview prevents movement mistakes before they happen
- Foundation for all positioning-based tactics (flanking, cover, chokepoints)
- Smooth movement animation creates satisfying visual feedback
- Prepares for attack of opportunity system (leaving threatened tiles)

### Success Criteria

| Criterion | Measurement |
|-----------|-------------|
| Valid moves visible | All tiles within movement range highlighted when unit selected |
| Path preview works | Blue line shows path from unit to hovered tile |
| Movement executes | Clicking valid tile moves unit along calculated path |
| Invalid moves blocked | Cannot move to obstacles, occupied tiles, or out of range |
| Animation smooth | Unit moves tile-by-tile with visible motion (not teleport) |
| State updates | Unit's grid position updates after movement completes |

---

## 2. Design Pillar Alignment

| Pillar | How This Feature Supports It |
|--------|------------------------------|
| **Tactical Combat** | Movement enables all positioning tactics - flanking, cover usage, chokepoint control. Players see exactly where they can move before committing. |
| **Build & Command** | Smooth movement with path preview makes commanding multiple units feel responsive and professional, reinforcing the "competent commander" fantasy. |
| **Meaningful Choice** | Movement range forces opportunity cost decisions - move far for flanking or stay close for safety? Can't do everything, must prioritize. |

---

## 3. How It Works

### Overview

When a friendly unit is selected (Task 1.4), the combat grid highlights all tiles within that unit's movement range. Tiles are highlighted in green with transparency, making it clear where the unit can go. As the player hovers over highlighted tiles, a blue path line draws from the unit to the cursor, showing the exact route the unit will take.

Clicking on a valid highlighted tile triggers movement. The unit animates along the calculated path tile-by-tile, taking 0.15 seconds per tile. During movement, the unit cannot be interacted with. Once movement completes, the unit is deselected and ready for action (or turn ends, depending on turn system state).

The pathfinding uses Godot's AStar2D algorithm, which handles obstacle avoidance automatically. Diagonal movement costs 1.5 tiles (per GDD), so a unit with 5 movement might only reach 3 diagonal tiles away.

### User Flow

```
1. Player has a unit selected (from Task 1.4)
2. Valid movement tiles highlight in green overlay
3. Player hovers over a valid tile
4. Blue path line appears from unit to hovered tile
5. Player clicks the tile
6. Unit begins moving along the path
7. Unit animates tile-by-tile (0.15s per tile)
8. Movement completes, unit arrives at destination
9. Unit is deselected
10. Player can select another unit or take action
```

### Rules & Constraints

- **Movement Range**: Each unit has a movement_range stat (Fighter = 5 tiles)
- **Diagonal Cost**: Diagonal moves cost 1.5 tiles (2 diagonals = 3 movement)
- **Obstacle Blocking**: Cannot path through obstacle tiles
- **Unit Blocking**: Cannot move through or onto tiles occupied by other units
- **Path Calculation**: Uses shortest valid path via AStar2D
- **Movement State**: Unit is "busy" during movement, cannot be selected or interacted with
- **Deselection**: Unit automatically deselected after movement completes
- **Single Move**: Unit cannot move again until next turn (future: turn system handles this)

### Edge Cases

- **No valid moves**: If unit is completely surrounded, no tiles highlight (rare but possible)
- **Click on invalid tile**: Nothing happens, unit remains selected
- **Click on obstacle**: Nothing happens, treated as invalid
- **Click on occupied tile**: Nothing happens, unit cannot stack
- **Click outside grid**: Nothing happens, click ignored
- **Path becomes blocked**: If another unit moves into path mid-movement (future consideration)
- **Unit dies during move**: Movement interrupted, unit removed (future: attack of opportunity)
- **Clicking same tile**: Unit already there, no movement needed

---

## 4. User Interaction

### Controls

| Input | Action |
|-------|--------|
| Left-click friendly unit | Select unit (Task 1.4), shows movement range |
| Mouse hover over tile | Shows path preview if tile is valid |
| Left-click valid tile | Execute movement along path |
| Left-click invalid tile | Nothing (click ignored) |
| Left-click empty space | Deselect unit (cancel movement intent) |
| Right-click (future) | Alternative deselect or context menu |

### Visual Feedback

| Event | Visual Response |
|-------|-----------------|
| Unit selected | Valid tiles highlight green (40% opacity) |
| Hover valid tile | Blue path line appears from unit to tile |
| Hover invalid tile | No path line, cursor may change to "blocked" |
| Click valid tile | Highlights fade, unit begins moving |
| Unit moving | Unit position animates along path |
| Movement complete | Unit at new position, no highlights |
| Deselected | All highlights removed |

### Audio Feedback (Future Polish)

- Movement start: Footstep sound
- Movement loop: Soft footsteps during animation
- Movement end: Arrival sound
- Invalid click: Soft "denied" sound

---

## 5. Visual Design

### Movement Range Overlay

```
When unit at center is selected, valid tiles show green overlay:

    ┌───┬───┬───┬───┬───┬───┬───┐
    │   │   │ ░ │ ░ │ ░ │   │   │
    ├───┼───┼───┼───┼───┼───┼───┤
    │   │ ░ │ ░ │ ░ │ ░ │ ░ │   │
    ├───┼───┼───┼───┼───┼───┼───┤
    │ ░ │ ░ │ ░ │ ░ │ ░ │ ░ │ ░ │
    ├───┼───┼───┼───┼───┼───┼───┤
    │ ░ │ ░ │ ░ │ U │ ░ │ ░ │ ░ │  U = Unit (center)
    ├───┼───┼───┼───┼───┼───┼───┤  ░ = Valid move (green)
    │ ░ │ ░ │ ░ │ ░ │ ░ │ ░ │ ░ │
    ├───┼───┼───┼───┼───┼───┼───┤
    │   │ ░ │ ░ │ ░ │ ░ │ ░ │   │
    ├───┼───┼───┼───┼───┼───┼───┤
    │   │   │ ░ │ ░ │ ░ │   │   │
    └───┴───┴───┴───┴───┴───┴───┘
```

### Path Preview Line

```
Blue line from unit to hovered tile:

    ┌───┬───┬───┬───┬───┬───┬───┐
    │   │   │   │   │   │   │ X │  X = Hover target
    ├───┼───┼───┼───┼───┼───┼───┤
    │   │   │   │   │   │ ↗ │   │  ↗ = Path direction
    ├───┼───┼───┼───┼───┼───┼───┤
    │   │   │   │   │ → │   │   │
    ├───┼───┼───┼───┼───┼───┼───┤
    │   │   │   │ U─┼───┘   │   │  U = Unit start
    └───┴───┴───┴───┴───┴───┴───┘

    Path line: 2px width, solid blue (#3498db)
```

### Color Palette

| Element | Color | Hex | Opacity | Usage |
|---------|-------|-----|---------|-------|
| Valid tile overlay | Green | #27ae60 | 40% | Tiles within movement range |
| Path preview line | Blue | #3498db | 100% | Path from unit to target |
| Invalid/blocked | Red | #e74c3c | 30% | Optional: tiles that can't be reached |
| Current position | Yellow | #f1c40f | 50% | Unit's current tile (optional) |

### Specifications

| Property | Value | Rationale |
|----------|-------|-----------|
| Valid tile overlay | 64x64 ColorRect at 40% alpha | Covers tile without obscuring base |
| Path line width | 2 pixels | Visible but not overwhelming |
| Path line style | Solid, center-to-center | Connects tile centers for clarity |
| Movement range (Fighter) | 5 tiles | From GDD - medium armor |
| Diagonal cost | 1.5 tiles | From GDD - realistic movement |

---

## 6. Technical Implementation

### Scene Structure

```
CombatGrid.tscn (Modified)
├── CombatGrid (Node2D) [root]
│   ├── TileMapLayer [existing]
│   ├── MovementOverlay (Node2D) [NEW]
│   │   └── (ColorRect children generated dynamically)
│   └── PathPreview (Line2D) [NEW]

Unit.tscn (Modified)
├── Unit (Node2D) [root]
│   ├── Sprite2D [existing]
│   ├── LetterLabel [existing]
│   ├── HPBar [existing]
│   └── (No new nodes - movement logic in script)
```

### New Files

**scripts/combat/pathfinding.gd**
```gdscript
## Pathfinding - AStar2D wrapper for grid-based movement
## Part of: Blood & Gold Prototype
## Spec: docs/features/1.5-click-to-move-path-preview.md
class_name Pathfinding
extends RefCounted

# ===== CONSTANTS =====
const CARDINAL_COST: float = 1.0
const DIAGONAL_COST: float = 1.5

# ===== STATE =====
var _astar: AStar2D
var _grid_width: int
var _grid_height: int
var _walkable_tiles: Dictionary = {}  # Vector2i -> bool
var _occupied_tiles: Dictionary = {}  # Vector2i -> Unit

# ===== INITIALIZATION =====
func initialize(grid_width: int, grid_height: int) -> void:
    ## Set up AStar2D for the grid
    _grid_width = grid_width
    _grid_height = grid_height
    _astar = AStar2D.new()
    _build_graph()

func _build_graph() -> void:
    ## Build the pathfinding graph from walkable tiles
    _astar.clear()

    # Add all points
    for x in range(_grid_width):
        for y in range(_grid_height):
            var coords = Vector2i(x, y)
            var id = _coords_to_id(coords)
            _astar.add_point(id, Vector2(x, y))

    # Connect adjacent points
    for x in range(_grid_width):
        for y in range(_grid_height):
            var coords = Vector2i(x, y)
            _connect_neighbors(coords)

func _connect_neighbors(coords: Vector2i) -> void:
    ## Connect a point to its walkable neighbors
    var id = _coords_to_id(coords)
    var neighbors = _get_neighbor_coords(coords)

    for neighbor in neighbors:
        if not _is_valid_coords(neighbor):
            continue

        var neighbor_id = _coords_to_id(neighbor)
        if _astar.are_points_connected(id, neighbor_id):
            continue

        # Calculate cost (diagonal = 1.5, cardinal = 1.0)
        var is_diagonal = (neighbor.x != coords.x and neighbor.y != coords.y)
        var cost = DIAGONAL_COST if is_diagonal else CARDINAL_COST

        _astar.connect_points(id, neighbor_id)
        # Note: AStar2D uses uniform cost by default
        # We handle variable cost in get_reachable_tiles()

func _get_neighbor_coords(coords: Vector2i) -> Array[Vector2i]:
    ## Get all 8 neighboring coordinates
    var neighbors: Array[Vector2i] = []
    for dx in range(-1, 2):
        for dy in range(-1, 2):
            if dx == 0 and dy == 0:
                continue
            neighbors.append(Vector2i(coords.x + dx, coords.y + dy))
    return neighbors

# ===== PUBLIC API =====
func set_tile_walkable(coords: Vector2i, walkable: bool) -> void:
    ## Mark a tile as walkable or blocked
    _walkable_tiles[coords] = walkable
    _astar.set_point_disabled(_coords_to_id(coords), not walkable)

func set_tile_occupied(coords: Vector2i, unit: Unit) -> void:
    ## Mark a tile as occupied by a unit
    if unit:
        _occupied_tiles[coords] = unit
    else:
        _occupied_tiles.erase(coords)

func is_tile_blocked(coords: Vector2i) -> bool:
    ## Check if tile is blocked (obstacle or occupied)
    if not _is_valid_coords(coords):
        return true
    if not _walkable_tiles.get(coords, true):
        return true
    if _occupied_tiles.has(coords):
        return true
    return false

func get_path(from: Vector2i, to: Vector2i) -> Array[Vector2i]:
    ## Get path from one tile to another
    if is_tile_blocked(to):
        return []

    var from_id = _coords_to_id(from)
    var to_id = _coords_to_id(to)

    var path_points = _astar.get_point_path(from_id, to_id)
    var path: Array[Vector2i] = []

    for point in path_points:
        path.append(Vector2i(int(point.x), int(point.y)))

    return path

func get_path_cost(path: Array[Vector2i]) -> float:
    ## Calculate total movement cost for a path
    if path.size() < 2:
        return 0.0

    var total_cost: float = 0.0
    for i in range(1, path.size()):
        var prev = path[i - 1]
        var curr = path[i]
        var is_diagonal = (prev.x != curr.x and prev.y != curr.y)
        total_cost += DIAGONAL_COST if is_diagonal else CARDINAL_COST

    return total_cost

func get_reachable_tiles(from: Vector2i, movement_range: float) -> Array[Vector2i]:
    ## Get all tiles reachable within movement range
    var reachable: Array[Vector2i] = []
    var visited: Dictionary = {}
    var queue: Array = [[from, 0.0]]  # [coords, cost_so_far]

    visited[from] = true

    while queue.size() > 0:
        var current = queue.pop_front()
        var coords: Vector2i = current[0]
        var cost: float = current[1]

        if cost <= movement_range and coords != from:
            if not is_tile_blocked(coords):
                reachable.append(coords)

        # Check neighbors
        for neighbor in _get_neighbor_coords(coords):
            if visited.has(neighbor):
                continue
            if not _is_valid_coords(neighbor):
                continue
            if is_tile_blocked(neighbor):
                continue

            var is_diagonal = (neighbor.x != coords.x and neighbor.y != coords.y)
            var move_cost = DIAGONAL_COST if is_diagonal else CARDINAL_COST
            var new_cost = cost + move_cost

            if new_cost <= movement_range:
                visited[neighbor] = true
                queue.append([neighbor, new_cost])

    return reachable

# ===== INTERNAL HELPERS =====
func _coords_to_id(coords: Vector2i) -> int:
    ## Convert 2D coords to unique ID
    return coords.y * _grid_width + coords.x

func _id_to_coords(id: int) -> Vector2i:
    ## Convert ID back to 2D coords
    return Vector2i(id % _grid_width, id / _grid_width)

func _is_valid_coords(coords: Vector2i) -> bool:
    ## Check if coords are within grid bounds
    return coords.x >= 0 and coords.x < _grid_width and coords.y >= 0 and coords.y < _grid_height
```

### Script Modifications

**combat_grid.gd (Add to existing)**
```gdscript
# ===== MOVEMENT OVERLAY (Task 1.5) =====
const COLOR_VALID_MOVE: Color = Color("#27ae60", 0.4)  # 40% opacity green
const COLOR_PATH_LINE: Color = Color("#3498db")  # Blue

var _movement_overlay: Node2D
var _path_preview: Line2D
var _valid_move_tiles: Array[Vector2i] = []
var pathfinding: Pathfinding

func _ready() -> void:
    # ... existing code ...
    _setup_movement_overlay()
    _setup_path_preview()
    _setup_pathfinding()

func _setup_movement_overlay() -> void:
    ## Create container for movement highlight tiles
    _movement_overlay = Node2D.new()
    _movement_overlay.name = "MovementOverlay"
    _movement_overlay.z_index = 5  # Above tiles, below units
    add_child(_movement_overlay)

func _setup_path_preview() -> void:
    ## Create Line2D for path preview
    _path_preview = Line2D.new()
    _path_preview.name = "PathPreview"
    _path_preview.width = 2.0
    _path_preview.default_color = COLOR_PATH_LINE
    _path_preview.z_index = 6
    add_child(_path_preview)

func _setup_pathfinding() -> void:
    ## Initialize pathfinding with grid data
    pathfinding = Pathfinding.new()
    pathfinding.initialize(GRID_WIDTH, GRID_HEIGHT)

    # Mark obstacles as non-walkable
    for x in range(GRID_WIDTH):
        for y in range(GRID_HEIGHT):
            var coords = Vector2i(x, y)
            pathfinding.set_tile_walkable(coords, is_walkable(coords))

func show_movement_range(from: Vector2i, movement_range: float) -> void:
    ## Display valid movement tiles for a unit
    clear_movement_overlay()
    _valid_move_tiles = pathfinding.get_reachable_tiles(from, movement_range)

    for coords in _valid_move_tiles:
        var overlay = ColorRect.new()
        overlay.color = COLOR_VALID_MOVE
        overlay.size = Vector2(TILE_SIZE, TILE_SIZE)
        overlay.position = Vector2(coords.x * TILE_SIZE, coords.y * TILE_SIZE)
        _movement_overlay.add_child(overlay)

func clear_movement_overlay() -> void:
    ## Remove all movement highlights
    for child in _movement_overlay.get_children():
        child.queue_free()
    _valid_move_tiles.clear()
    _path_preview.clear_points()

func show_path_preview(from: Vector2i, to: Vector2i) -> void:
    ## Draw path line from unit to target tile
    _path_preview.clear_points()

    if not _valid_move_tiles.has(to):
        return  # Not a valid destination

    var path = pathfinding.get_path(from, to)
    for coords in path:
        var world_pos = grid_to_world(coords) - position  # Local coords
        _path_preview.add_point(world_pos)

func hide_path_preview() -> void:
    ## Clear the path preview line
    _path_preview.clear_points()

func is_valid_move_tile(coords: Vector2i) -> bool:
    ## Check if a tile is in the current valid move set
    return _valid_move_tiles.has(coords)

func update_occupied_tiles(units: Array[Unit]) -> void:
    ## Update pathfinding with current unit positions
    # Clear all occupied tiles first
    for x in range(GRID_WIDTH):
        for y in range(GRID_HEIGHT):
            pathfinding.set_tile_occupied(Vector2i(x, y), null)

    # Mark current unit positions
    for unit in units:
        pathfinding.set_tile_occupied(unit.grid_position, unit)
```

**unit.gd (Add to existing)**
```gdscript
# ===== MOVEMENT (Task 1.5) =====
const MOVE_DURATION_PER_TILE: float = 0.15  # Seconds

signal movement_started(unit: Unit)
signal movement_finished(unit: Unit)

@export var movement_range: int = 5  # Tiles per turn

var _is_moving: bool = false
var _movement_tween: Tween

func is_moving() -> bool:
    ## Check if unit is currently animating movement
    return _is_moving

func move_along_path(path: Array[Vector2i]) -> void:
    ## Animate unit movement along a path
    if path.size() < 2:
        return  # Need at least start and end

    _is_moving = true
    movement_started.emit(self)

    # Cancel any existing tween
    if _movement_tween and _movement_tween.is_running():
        _movement_tween.kill()

    _movement_tween = create_tween()
    _movement_tween.set_ease(Tween.EASE_IN_OUT)
    _movement_tween.set_trans(Tween.TRANS_LINEAR)

    # Animate through each tile in path (skip first - we're already there)
    for i in range(1, path.size()):
        var target_coords = path[i]
        var target_pos = combat_grid.grid_to_world(target_coords)
        _movement_tween.tween_property(self, "position", target_pos, MOVE_DURATION_PER_TILE)

    # Update grid position to final destination
    var final_coords = path[path.size() - 1]
    _movement_tween.tween_callback(_on_movement_complete.bind(final_coords))

func _on_movement_complete(final_coords: Vector2i) -> void:
    ## Called when movement animation finishes
    var old_pos = grid_position
    grid_position = final_coords
    _is_moving = false
    movement_finished.emit(self)
    unit_moved.emit(self, old_pos, final_coords)
```

### Integration Points

| System | Integration |
|--------|-------------|
| Selection (Task 1.4) | When unit selected, call `combat_grid.show_movement_range()` |
| Turn Manager (Task 1.8) | After movement, mark unit as "has moved" |
| Combat Manager | Connect to movement signals, update occupied tiles |
| Attack System (Task 1.7) | Check if enemy is adjacent after movement |
| Attack of Opportunity (Phase 2) | Check for threatened tiles during path |

### Signals

```gdscript
# In Unit
signal movement_started(unit: Unit)
signal movement_finished(unit: Unit)

# In CombatGrid (existing)
signal tile_clicked(coords: Vector2i)
signal tile_hovered(coords: Vector2i)
```

---

## 7. File Structure

```
scripts/
└── combat/
    ├── pathfinding.gd         # NEW - AStar2D wrapper
    ├── combat_grid.gd         # MODIFIED - Add overlay, path preview
    └── unit.gd                # MODIFIED - Add movement execution

scenes/
└── combat/
    ├── CombatGrid.tscn        # MODIFIED - Add overlay nodes
    └── Unit.tscn              # No changes needed

# MovementOverlay and PathPreview created programmatically in combat_grid.gd
```

---

## 8. Acceptance Criteria

Feature is complete when:

- [ ] Selecting a friendly unit highlights all reachable tiles in green
- [ ] Movement range respects unit's movement_range stat (Fighter = 5)
- [ ] Diagonal movement costs 1.5 tiles (calculated correctly)
- [ ] Obstacle tiles are excluded from valid moves
- [ ] Tiles occupied by other units are excluded
- [ ] Hovering over valid tile shows blue path line
- [ ] Path line connects tile centers for clarity
- [ ] Clicking valid tile initiates movement
- [ ] Unit animates tile-by-tile (0.15s per tile)
- [ ] Unit position updates to destination after movement
- [ ] Unit deselects after movement completes
- [ ] Clicking invalid tile does nothing (unit stays selected)
- [ ] Movement overlay clears after movement or deselection
- [ ] Path preview clears after movement or deselection

---

## 9. Testing Checklist

### Functional Tests

- [ ] Unit with 5 movement can reach tiles 5 tiles away (cardinal)
- [ ] Unit with 5 movement can reach tiles 3 tiles away (diagonal - costs 4.5)
- [ ] Pathfinding routes around obstacles correctly
- [ ] Pathfinding routes around other units
- [ ] Path cost calculation accurate (cardinal = 1, diagonal = 1.5)
- [ ] Movement animation plays at correct speed (0.15s/tile)
- [ ] Unit's grid_position updated after movement
- [ ] unit_moved signal emitted with correct coordinates

### Visual Tests

- [ ] Green overlay visible and properly positioned on tiles
- [ ] Overlay opacity is 40% (tiles still visible underneath)
- [ ] Blue path line clearly visible
- [ ] Path line connects tile centers
- [ ] Line disappears when hovering invalid tile
- [ ] All overlays clear when unit deselects

### Edge Case Tests

- [ ] Unit surrounded by obstacles shows no valid moves
- [ ] Unit at grid edge doesn't show out-of-bounds tiles
- [ ] Clicking on unit's current tile does nothing
- [ ] Clicking rapidly doesn't break animation
- [ ] Moving to tile adjacent to enemy works (for attack in Task 1.7)
- [ ] Very long paths (corner to corner) calculate correctly

### Integration Tests

- [ ] Selection indicator (Task 1.4) compatible with movement overlay
- [ ] HP bars (Task 1.3) remain visible during movement
- [ ] Multiple units can move in sequence (test with debug)
- [ ] Grid API functions work correctly with new features

### Performance Tests

- [ ] Movement overlay renders without frame drop
- [ ] Path calculation is instantaneous (<10ms for 12x12 grid)
- [ ] Animation is smooth at 60 FPS
- [ ] No memory leaks from overlay nodes

---

## 10. Implementation Notes

### Approach Rationale

**Why AStar2D over manual BFS?**
- Built-in Godot class, well-optimized
- Handles weighted paths (for future terrain costs)
- Provides point connections for multiple path calculations
- Less code to maintain

**Why ColorRect for overlay instead of TileMap layer?**
- Simpler to add/remove dynamically
- No need for additional tileset
- Easier to customize colors and opacity
- Can be extended with sprites/effects later

**Why separate Pathfinding class?**
- Encapsulates AStar2D complexity
- Reusable for enemy AI pathfinding
- Easier to unit test
- Single responsibility principle

**Why 0.15s per tile?**
- Fast enough to not feel sluggish
- Slow enough to see the movement
- Total time for 5-tile move: 0.75s (feels snappy)
- Matches similar tactical games

### Gotchas to Watch

1. **Coordinate spaces**: Path preview uses local coordinates relative to grid
2. **Tween cleanup**: Must kill existing tween before starting new movement
3. **Occupied tile updates**: Must update pathfinding when any unit moves
4. **Z-index ordering**: Overlay (5) < Units (10) < UI
5. **Diagonal blocking**: In some games, diagonal movement blocked if adjacent tiles are obstacles - we're not implementing this for prototype
6. **Unit reference in pathfinding**: Store weak references or update frequently

### Future Considerations

- **Terrain costs**: Difficult terrain (water, rubble) costs 2 tiles per move
- **Attack of opportunity**: Leaving threatened tiles triggers enemy reaction
- **Dash ability**: Some abilities might extend movement range
- **Group movement**: Soldier orders might move multiple units at once
- **Fog of war**: Movement might reveal hidden tiles

---

## 11. Definition of Done

- [ ] `pathfinding.gd` created with full AStar2D wrapper
- [ ] `combat_grid.gd` updated with overlay and path preview
- [ ] `unit.gd` updated with movement animation
- [ ] Movement overlay displays correctly
- [ ] Path preview displays correctly
- [ ] Click-to-move executes correctly
- [ ] Animation smooth at 0.15s per tile
- [ ] All acceptance criteria pass
- [ ] Debug tested with multiple units
- [ ] Code follows GDScript style guidelines
- [ ] Ready for Task 1.6 (Turn Order UI Panel)

---

## 12. References

### From GDD

- **Movement speeds**: "Light armor: 6 tiles, Medium armor: 5 tiles, Heavy armor: 4 tiles" (Section 3)
- **Diagonal cost**: "Diagonal movement costs 1.5 tiles" (Section 3)
- **Combat state machine**: "Idle → Selected → Moving → Acting → Done" (Section 10)
- **Pathfinding**: "AStar2D" listed in Key Systems (Section 10)

### From Roadmap

- **Task 1.5**: Click-to-Move with Path Preview (Phase 1, 3 hours)
- **Dependencies**: Task 1.4 (selection must work)
- **Leads to**: Task 1.6 (Turn Order UI), Task 1.7 (Attack)

### Godot Documentation

- [AStar2D](https://docs.godotengine.org/en/stable/classes/class_astar2d.html)
- [Line2D](https://docs.godotengine.org/en/stable/classes/class_line2d.html)
- [Tween](https://docs.godotengine.org/en/stable/classes/class_tween.html)
- [ColorRect](https://docs.godotengine.org/en/stable/classes/class_colorrect.html)
