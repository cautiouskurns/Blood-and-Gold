# Task 2.14: Enemy AI Basic

**Status:** ðŸŸ¢ Implemented
**Priority:** â¬†ï¸ High
**Estimated Time:** 2.5 hours
**Dependencies:** Task 2.7 (ranged attack system), Task 2.8 (soldier unit type - provides targets)
**Assigned To:** AI assistant

---

## Purpose

**Why does this feature exist?**
Without enemy AI, combat is one-sided - enemies just stand there waiting to be killed. The prototype needs enemies that fight back intelligently to test whether the tactical combat system is actually engaging. Enemy behavior creates the tactical puzzle that players must solve. The GDD explicitly calls for enemies that "rush nearest target," "stay at range," and "use abilities" - without this, we can't validate the core combat loop.

**What does it enable?**
- Enemies act autonomously during their turns without player input
- Different enemy types exhibit distinct tactical behaviors (melee rush, ranged kiting, support)
- Combat becomes a real tactical challenge with meaningful positioning decisions
- The prototype can test whether 4 party + 4 soldiers vs 8-10 enemies feels strategic
- Enemy leaders create priority target decisions (take out the buffer first?)

**Success criteria:**
- Enemies take their turns automatically when it's their turn in initiative
- Melee bandits close distance and engage in melee combat
- Ranged bandits maintain distance and shoot priority targets
- Bandit leaders stay protected and buff their allies
- Player feels challenged by enemy tactics, not just enemy numbers

---

## How It Works

### Overview

The Enemy AI system executes enemy turns automatically when the TurnManager signals an enemy's turn. Each enemy type has a distinct behavior pattern defined by an AI "role" that determines target selection, movement priority, and action choice.

The system follows a simple decision tree approach (not a full behavior tree for prototype scope). On each enemy's turn, the AI evaluates:
1. **Target Selection:** Who should I attack? (based on aggro priority)
2. **Positioning:** Where should I move? (based on role - close distance or maintain range)
3. **Action:** What should I do? (attack, use ability, or defend)

The AI uses the same attack resolution and movement systems as player-controlled units, ensuring consistent rules. Enemy turns include brief delays between actions for visual clarity - players need to see what enemies are doing.

### AI Roles

**MELEE (Bandit, Infantry-type enemies)**
- Aggro: Target lowest HP enemy within reach, then nearest
- Movement: Path toward target, get adjacent
- Action: Basic melee attack when adjacent

**RANGED (Bandit Archer, Mage-type enemies)**
- Aggro: Target lowest HP enemy in range
- Movement: Maintain preferred range (5-8 tiles), retreat if enemies too close
- Action: Ranged attack from distance

**LEADER (Bandit Leader, Boss-type enemies)**
- Aggro: Target highest-threat enemy (most damage dealt) or lowest HP
- Movement: Stay behind melee allies, avoid frontline
- Action: Use buff abilities first (Rally Bandits), then attack

**TANK (Ironmark Soldier)**
- Aggro: Target nearest enemy threatening allies
- Movement: Hold position, form shield wall with adjacent allies
- Action: Attack enemies that approach

### User Flow

```
1. TurnManager signals enemy unit's turn
2. EnemyAI.execute_turn(enemy) called
3. AI evaluates role and current battlefield state
4. AI selects target based on aggro priority
5. AI calculates optimal move position
6. If movement needed: Enemy moves (animated, 0.15s per tile)
7. Brief delay (0.2s) for visual clarity
8. AI selects action (attack or ability)
9. Enemy executes attack/ability (damage numbers, effects)
10. Brief delay (0.3s) before ending turn
11. EnemyAI signals turn complete
12. TurnManager advances to next unit
```

### Rules & Constraints

- **Turn Timing:** Enemy turns include visual delays for player comprehension
- **Action Limit:** One move + one action per turn (same as player units)
- **Valid Targets:** Only attack party members and soldiers (not other enemies)
- **Line of Sight:** Ranged enemies respect LoS rules from Task 2.7
- **Terrain Bonuses:** Enemies benefit from cover/high ground (Task 2.12)
- **Attack of Opportunity:** Enemies trigger AoO when moving away from threats
- **No Cheating:** AI uses same pathfinding and attack resolution as players

### Aggro Priority System

Enemies choose targets based on weighted priority:

| Priority | Condition | Weight |
|----------|-----------|--------|
| 1 (Highest) | Target has lowest HP% | +50 |
| 2 | Target dealt most damage this battle | +30 |
| 3 | Target is within weapon range | +20 |
| 4 | Target is nearest by tile distance | +10 |
| 5 | Target is a soldier (vs party member) | -10 |

Higher total weight = more likely target. Ties broken by distance (prefer nearest).

### Edge Cases

- **No Valid Targets:** Enemy ends turn without acting (all targets dead or unreachable)
- **Surrounded:** Melee enemy attacks best adjacent target instead of moving
- **Cornered Ranged:** Archer forced into melee attacks if can't retreat
- **Leader Alone:** Leader fights directly if no allies remain to buff
- **Blocked Path:** Enemy moves as close as possible, then attacks if in range
- **Low HP Enemy:** No special flee behavior for prototype (fight to the death)
- **Ability on Cooldown:** Leader uses basic attack if Rally already used

---

## User Interaction

### Controls

**None** - Enemy turns are fully autonomous. Player watches enemy actions unfold.

### Visual Feedback

- **Turn Indicator:** Turn order panel highlights current enemy
- **Selection Glow:** Active enemy has distinct selection indicator (red glow)
- **Movement Animation:** Enemy visibly moves along path (same as player units)
- **Attack Animation:** Enemy attacks show targeting line, damage numbers
- **Ability Effects:** Buff abilities show visual effect on buffed allies
- **Delay Between Actions:** Clear pauses so player can follow what's happening

### Audio Feedback (if applicable)

- Movement sounds (footsteps) during enemy movement
- Attack sounds (weapon hit/miss) during enemy attacks
- Ability activation sound for leader's Rally Bandits
- Distinct "enemy turn" sound cue when enemy turn begins (optional)

---

## Visual Design

### Layout

No UI elements created - enemy AI uses existing combat UI:
- Turn Order Panel shows enemy turns
- Damage numbers appear for enemy attacks
- Combat log records enemy actions

### Enemy Selection Indicator

When it's an enemy's turn:
- Enemy unit has red pulsing selection indicator
- Turn order icon for that enemy is highlighted
- Other enemies remain in normal state

### Action Visualization

```
MELEE ATTACK:
1. Enemy moves toward target (animated path)
2. Brief pause at destination
3. Attack animation (unit lunges/swings)
4. Damage number appears on target
5. Target HP bar updates

RANGED ATTACK:
1. Enemy repositions if needed
2. Targeting line briefly shown from attacker to target
3. Projectile or instant hit effect
4. Damage number appears on target

LEADER BUFF (Rally Bandits):
1. Leader plays "rally" animation (arms raised)
2. Golden glow pulses outward from leader
3. All nearby bandits briefly flash gold
4. Buff icon appears above buffed units
5. Combat log shows "Bandit Leader uses Rally Bandits!"
```

---

## Technical Implementation

### Scene Structure

No new scenes required. EnemyAI is a static utility class (like SoldierAI).

```
scripts/combat/enemy_ai.gd (new file)
â”œâ”€â”€ Static class (no instantiation)
â”œâ”€â”€ execute_turn(enemy: Unit) - Main entry point
â”œâ”€â”€ Role-specific behavior methods
â””â”€â”€ Target selection and pathfinding helpers
```

### Script Responsibilities

**enemy_ai.gd (create):**
- `execute_turn(enemy: Unit, combat_grid: CombatGrid)` - Main entry point called by TurnManager
- `_determine_role(enemy: Unit) -> String` - Get AI role based on enemy type
- `_select_target(enemy: Unit, role: String) -> Unit` - Choose target based on aggro
- `_calculate_target_priority(enemy: Unit, target: Unit) -> int` - Aggro weight calculation
- `_get_desired_position(enemy: Unit, target: Unit, role: String) -> Vector2i` - Optimal tile
- `_execute_movement(enemy: Unit, destination: Vector2i)` - Animated movement
- `_execute_attack(enemy: Unit, target: Unit)` - Perform attack action
- `_execute_ability(enemy: Unit)` - Use special ability if available
- `_should_use_ability(enemy: Unit) -> bool` - Check if ability use is appropriate
- `_end_enemy_turn()` - Signal turn completion to CombatManager

**turn_manager.gd (modify):**
- Replace placeholder enemy turn handling with EnemyAI.execute_turn() call
- Connect to enemy turn completion signal

### Integration Points

- **Connects to:**
  - `TurnManager` - Called when enemy turn starts
  - `CombatManager` - Get combat grid, all units
  - `AttackResolver` - Use standard attack resolution
  - `Pathfinding` - Use standard pathfinding
  - `Unit` - Execute movement, attacks

- **Listens for:**
  - `TurnManager.turn_started` - Check if it's an enemy turn

- **Modifies:**
  - Nothing directly - uses existing systems for actions

- **Emits (via CombatManager):**
  - Signals for movement, attack completion (existing signals)

### Configuration

**AI Role Mapping (enemy_ai.gd):**
```gdscript
const ROLE_MELEE = "melee"
const ROLE_RANGED = "ranged"
const ROLE_LEADER = "leader"
const ROLE_TANK = "tank"

const ENEMY_ROLES: Dictionary = {
    Unit.UnitType.BANDIT_MELEE: ROLE_MELEE,
    Unit.UnitType.BANDIT_ARCHER: ROLE_RANGED,
    Unit.UnitType.BANDIT_LEADER: ROLE_LEADER,
    Unit.UnitType.IRONMARK_SOLDIER: ROLE_TANK,
    Unit.UnitType.IRONMARK_KNIGHT: ROLE_MELEE,
}
```

**Timing Constants:**
```gdscript
const MOVE_DELAY: float = 0.15      # Seconds per tile during movement
const ACTION_DELAY: float = 0.2     # Pause before action
const TURN_END_DELAY: float = 0.3   # Pause after action before ending turn
```

**Aggro Weights:**
```gdscript
const AGGRO_LOW_HP: int = 50
const AGGRO_HIGH_THREAT: int = 30
const AGGRO_IN_RANGE: int = 20
const AGGRO_NEAREST: int = 10
const AGGRO_SOLDIER_PENALTY: int = -10  # Prefer party members over soldiers
```

**Ranged AI Constants:**
```gdscript
const ARCHER_PREFERRED_RANGE_MIN: int = 5
const ARCHER_PREFERRED_RANGE_MAX: int = 8
const ARCHER_RETREAT_THRESHOLD: int = 3  # Retreat if enemy closer than this
```

---

## Acceptance Criteria

Feature is complete when:

- [ ] Enemies act automatically on their turn without player input
- [ ] Melee enemies (Bandit Melee) move toward nearest enemy and attack
- [ ] Ranged enemies (Bandit Archer) maintain distance and shoot at range
- [ ] Leader enemies (Bandit Leader) use Rally Bandits ability appropriately
- [ ] Enemies respect turn order and action limits (move + action)
- [ ] Enemy actions are visually clear with appropriate delays
- [ ] Combat log records enemy actions ("Bandit attacks Thorne for 5 damage")
- [ ] Enemies use pathfinding to navigate around obstacles
- [ ] Ranged enemies check line of sight before attacking
- [ ] Different enemy types exhibit noticeably different behaviors

---

## Testing Checklist

### Functional Tests

- [ ] **Melee AI:** Place bandit 5 tiles from party member, verify it moves and attacks
- [ ] **Ranged AI:** Place archer 4 tiles from target, verify it backs up to preferred range
- [ ] **Leader AI:** Place leader with 2+ bandits, verify Rally Bandits used first turn
- [ ] **Target Selection:** Verify enemies target low HP units over full HP
- [ ] **Movement:** Verify enemies path around obstacles correctly
- [ ] **Attack Resolution:** Verify damage numbers and HP reduction work

### Edge Case Tests

- [ ] **No Path:** Enemy blocked by obstacles still attacks if in range
- [ ] **All Enemies Dead:** Victory triggers correctly after all enemies killed
- [ ] **Cornered Archer:** Archer forced to melee attacks if surrounded
- [ ] **Solo Leader:** Leader attacks directly when no allies to buff
- [ ] **Multiple Valid Targets:** Highest priority target selected correctly

### Integration Tests

- [ ] **With Turn System:** Enemy turns occur in correct initiative order
- [ ] **With Cover (Task 2.12):** Enemies benefit from cover defense bonus
- [ ] **With LoS (Task 2.7):** Ranged enemies blocked by obstacles don't shoot
- [ ] **With Soldiers:** Enemies can target and attack player's soldiers
- [ ] **With Abilities:** Leader's Rally Bandits actually buffs nearby enemies

### Performance Tests

- [ ] **Turn Speed:** Enemy turn completes within 2-3 seconds (not too fast, not slow)
- [ ] **No Hang:** AI decision-making doesn't freeze the game
- [ ] **Smooth Animation:** Movement and attacks animate without stuttering

---

## Implementation Notes

*(For AI assistant)*

### Key Considerations

1. **Pattern from SoldierAI:** Use the same structural pattern as `soldier_ai.gd` - static class with `execute_turn()` entry point. This maintains consistency and is proven to work.

2. **Await Pattern:** Use `await` for delays between actions (movement, attack, turn end). This ensures visual feedback is clear.

3. **Role Flexibility:** The role system should map easily to enemy UnitType. Default to MELEE for unknown types.

4. **Target Caching:** Calculate valid targets once at turn start, not repeatedly. Store damage dealt per unit for threat calculation.

5. **Fallback Behavior:** If preferred behavior fails (can't reach range, ability on cooldown), fall back to simpler behavior (move toward, basic attack).

### Integration with Existing Code

The TurnManager currently has this placeholder for enemy turns:
```gdscript
if unit.is_enemy:
    print("[TurnManager] Enemy turn skipped (AI placeholder)")
    await get_tree().create_timer(ENEMY_TURN_DELAY).timeout
    end_current_turn()
    return
```

Replace with:
```gdscript
if unit.is_enemy:
    print("[TurnManager] Enemy turn: %s" % unit.unit_name)
    await EnemyAI.execute_turn(unit, _combat_grid)
    end_current_turn()
    return
```

### Reference: SoldierAI Structure

Use the same pattern as `soldier_ai.gd`:
```gdscript
class_name EnemyAI
extends RefCounted

static func execute_turn(enemy: Unit, combat_grid: CombatGrid) -> void:
    if not is_instance_valid(enemy) or not enemy.is_alive():
        return

    var role = _determine_role(enemy)
    var target = _select_target(enemy, role)

    if target:
        await _execute_role_behavior(enemy, target, role, combat_grid)

    await _wait(TURN_END_DELAY)
    CombatManager.enemy_turn_complete.emit(enemy)
```

### Alternative Approaches Considered

1. **Behavior Trees:** Full behavior tree library would be more flexible but overkill for 3 enemy types. Rejected for prototype scope.

2. **State Machines:** Each enemy could have explicit state machine. Rejected - role-based decision tree is simpler and sufficient.

3. **Influence Maps:** AI could use heatmaps for positioning. Rejected - direct pathfinding is simpler and works for prototype.

4. **Goal-Oriented Action Planning:** GOAP would allow dynamic goal selection. Rejected - too complex for prototype needs.

---

## Hardcoded Values Reference

| Property | Value | Notes |
|----------|-------|-------|
| Move Delay | 0.15s per tile | Same as player movement |
| Action Delay | 0.2s | Pause before attacking |
| Turn End Delay | 0.3s | Pause before ending turn |
| Archer Preferred Range | 5-8 tiles | Sweet spot for ranged |
| Archer Retreat Threshold | 3 tiles | Back up if enemy closer |
| Aggro: Low HP Weight | +50 | Prioritize wounded targets |
| Aggro: High Threat Weight | +30 | Prioritize damage dealers |
| Aggro: In Range Weight | +20 | Prefer attackable targets |
| Aggro: Nearest Weight | +10 | Tiebreaker: pick closest |
| Aggro: Soldier Penalty | -10 | Prefer party over soldiers |
| Rally Bandits Buff | +2 attack | Duration: 2 turns |

---

## Asset Requirements

### No New Assets Needed

Enemy AI uses existing:
- Enemy unit sprites
- Attack animations
- Damage number system
- Movement pathfinding
- Combat log

### Optional Future Polish

- Enemy "thinking" indicator (small clock or ellipsis above head)
- Distinct enemy turn sound effect
- Rally Bandits visual effect (golden pulse)

---
