# Feature Spec: Implement Player Abilities

| Property | Value |
|----------|-------|
| **Feature ID** | 2.3 |
| **Status** | ðŸŸ¢ Implemented |
| **Priority** | ðŸ”¥ Critical |
| **Estimated Time** | 2.5 hours |
| **Phase** | Phase 2: Abilities & Party Interaction |
| **Dependencies** | Task 2.2 (Ability UI Panel) |

---

## 1. Purpose

### Why This Feature Exists

The player character is the heart of the mercenary company - a commander who leads from the front. Their 4 abilities define the "commander fantasy" central to Blood & Gold: Power Attack for decisive damage, Shield Bash for crowd control, Rally for troop leadership, and Basic Attack for consistent offense. This feature transforms the player from a simple attacker into a tactical leader who can shift the battlefield through their choices.

This directly supports the **Build & Command** design pillar by giving the player tools that affect both their personal combat and their soldiers' effectiveness.

### What It Enables

- **Power Attack**: High-risk, high-reward damage option (+50% damage, -2 to hit)
- **Shield Bash**: Crowd control via stun effect (enemy skips 1 turn)
- **Rally**: Troop leadership - buff all soldiers with +2 attack for 2 turns
- **Basic Attack**: Reliable standard melee attack (unlimited uses)
- Foundation for the Ability resource system used by all party members
- Status effect framework (Stun, Attack Buff) for future abilities
- Ability usage tracking (once-per-battle for special abilities)

### Success Criteria

| Criterion | Measurement |
|-----------|-------------|
| Power Attack damage | Deals 50% more damage than basic attack |
| Power Attack penalty | -2 to attack roll visible in combat log |
| Shield Bash stun | Target skips their next turn |
| Rally buff | Soldiers gain +2 attack bonus |
| Rally duration | Buff lasts 2 turns |
| Usage limits | Special abilities usable once per battle |
| Basic Attack unlimited | Can use basic attack every turn |
| Ability bar integration | All 4 abilities appear and are clickable |

---

## 2. Design Pillar Alignment

| Pillar | How This Feature Supports It |
|--------|------------------------------|
| **Build & Command** | Rally specifically buffs SOLDIERS, reinforcing the mercenary captain fantasy. The player doesn't just fight - they inspire and lead their troops. This is the core commander ability that makes soldiers feel like your army, not just extra units. |
| **Tactical Combat** | Power Attack vs Basic Attack is a classic tactical tradeoff: damage vs reliability. Shield Bash adds crowd control, creating positioning opportunities. Every ability choice matters based on battlefield state. |
| **Meaningful Choice** | Once-per-battle limits on special abilities forces prioritization. "When do I use Rally?" becomes a meaningful decision. Saving Shield Bash for the right enemy creates tension and planning. |
| **Character Progression** | These abilities define what the player character CAN do. Future upgrades could enhance these abilities (Power Attack +75%, Rally affecting party members, etc.), creating a progression path. |

---

## 3. How It Works

### Overview

The Player character has 4 abilities accessible through the Ability Bar UI (Task 2.2):

1. **Basic Attack**: Standard melee attack, unlimited uses, requires adjacent enemy
2. **Power Attack**: +50% damage but -2 to hit, once per battle, requires adjacent enemy
3. **Shield Bash**: Deals damage and stuns target for 1 turn, once per battle, requires adjacent enemy
4. **Rally**: Grants +2 attack bonus to all friendly soldiers for 2 turns, once per battle, no target required

All abilities are executed through the new Ability system, which consists of:
- **Ability Resource** (`ability.gd`): Data class defining ability properties
- **Ability Executor** (`ability_executor.gd`): Processes ability effects
- **Status Effect System**: Tracks buffs/debuffs on units

### User Flow

```
USING AN ABILITY:
1. Player unit's turn begins (selected automatically)
2. Player clicks ability button in Ability Bar
3. If ability requires target:
   a. Valid targets highlighted on grid
   b. Player clicks target unit
   c. Ability executes with target
4. If ability requires no target (Rally):
   a. Ability executes immediately
5. Ability effects applied:
   - Damage dealt (Power Attack, Shield Bash, Basic Attack)
   - Status effects applied (Stun, Attack Buff)
   - Ability marked as used (if once-per-battle)
6. Ability Bar refreshes (used abilities grayed out)
7. Turn ends (movement + action complete)

POWER ATTACK FLOW:
1. Select Power Attack from ability bar
2. Adjacent enemies highlighted
3. Click enemy to attack
4. Roll attack: d20 + attack_bonus - 2
5. If hit: Deal weapon_damage * 1.5
6. Power Attack marked as used this battle

SHIELD BASH FLOW:
1. Select Shield Bash from ability bar
2. Adjacent enemies highlighted
3. Click enemy to attack
4. Roll attack: d20 + attack_bonus (no penalty)
5. If hit: Deal weapon_damage + apply STUNNED status (1 turn)
6. Stunned enemy skips next turn
7. Shield Bash marked as used this battle

RALLY FLOW:
1. Select Rally from ability bar
2. No targeting needed - executes immediately
3. All friendly soldiers gain ATTACK_BUFF (+2 attack for 2 turns)
4. Visual buff indicator appears above buffed soldiers
5. Rally marked as used this battle
6. Buff expires after 2 turns (tracked per unit)
```

### Rules & Constraints

| Rule | Description |
|------|-------------|
| Adjacent only | Power Attack, Shield Bash, and Basic Attack require target in adjacent tile (8-way) |
| Once per battle | Power Attack, Shield Bash, and Rally can only be used once per battle |
| Basic Attack unlimited | Basic Attack can be used every turn |
| Soldiers only for Rally | Rally only affects units with `is_soldier = true`, not party members |
| Stun skips turn | Stunned units are automatically passed when their turn comes |
| Buff stacking | Attack buffs from Rally do not stack (refresh duration instead) |
| Dead targets | Cannot target dead units |
| Self-targeting | Cannot target self with attack abilities |

### Edge Cases

| Scenario | Behavior |
|----------|----------|
| No adjacent enemies | Attack abilities unavailable (grayed out) |
| All soldiers dead | Rally still usable but has no effect |
| Target dies from Shield Bash | Stun not applied (no point) |
| Stunned unit already has stun | Refresh stun duration |
| Rally used when no soldiers exist | Ability used up with no effect (player choice) |
| Battle restarts (retry) | All ability uses reset |
| Unit dies with active buff | Buff removed (no tracking needed) |
| Attack misses | No secondary effects applied (stun requires hit) |

---

## 4. User Interaction

### Controls

| Input | Action | Context |
|-------|--------|---------|
| Click ability button | Select ability | Player's turn, ability available |
| Click valid target | Execute ability | Ability selected, target valid |
| Click invalid target | No effect | Ability requires different target |
| Right-click / ESC | Cancel ability selection | Ability selected |
| Click empty tile | Cancel ability selection | Ability selected |

### Visual Feedback

| Event | Visual |
|-------|--------|
| Ability selected | Ability button highlighted, valid targets glow |
| Valid target hover | Target outline brightens |
| Power Attack hit | Larger damage number, screen shake (subtle) |
| Shield Bash hit | Stun icon appears above target |
| Rally activated | Buff particles rise from soldiers |
| Ability used | Button grays out in ability bar |
| Buff active | Small icon above affected soldiers |
| Buff expires | Icon fades and removes |

### Audio Feedback (Future)

| Event | Sound |
|-------|-------|
| Power Attack swing | Heavy weapon swing |
| Power Attack hit | Powerful impact |
| Shield Bash hit | Metal clang + grunt |
| Rally activated | Horn or shout |
| Buff applied | Positive chime |
| Buff expires | Subtle fade sound |

*Note: Audio is out of scope for prototype but noted for future.*

---

## 5. Visual Design

### Status Effect Icons

```
STUNNED (Above Unit):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â­    â”‚  Stars/swirl icon
â”‚  STUN   â”‚  (or dizzy spiral)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Size: 24x24 pixels
Color: Yellow (#f1c40f)

ATTACK BUFF (Above Soldier):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   âš”ï¸    â”‚  Sword/up-arrow icon
â”‚   +2    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Size: 24x24 pixels
Color: Green (#27ae60)
```

### Ability Icons (Placeholder)

| Ability | Icon Concept | Color |
|---------|--------------|-------|
| Basic Attack | Simple sword | Gray |
| Power Attack | Glowing sword | Orange/Red |
| Shield Bash | Shield with impact | Blue |
| Rally | Flag or horn | Gold |

### Combat Log Messages

```
[Combat] Player uses Power Attack on Bandit 1
[Combat] Attack roll: 15 - 2 = 13 vs DEF 12 -> HIT
[Combat] Power Attack deals 12 damage (8 x 1.5) to Bandit 1

[Combat] Player uses Shield Bash on Bandit 2
[Combat] Attack roll: 18 vs DEF 12 -> HIT
[Combat] Shield Bash deals 6 damage to Bandit 2
[Combat] Bandit 2 is STUNNED for 1 turn

[Combat] Player uses Rally
[Combat] 3 soldiers gain +2 attack for 2 turns

[Combat] Bandit 2's turn - STUNNED, skipping...
[Combat] Bandit 2 is no longer stunned
```

---

## 6. Technical Implementation

### Scene Structure

No new scenes required - abilities are data and logic only.

### File Structure

```
scripts/
â”œâ”€â”€ resources/
â”‚   â””â”€â”€ ability.gd                  # NEW: Ability resource class
â”œâ”€â”€ combat/
â”‚   â”œâ”€â”€ ability_executor.gd         # NEW: Executes ability effects
â”‚   â”œâ”€â”€ status_effect.gd            # NEW: Status effect data class
â”‚   â”œâ”€â”€ status_effect_manager.gd    # NEW: Manages active effects on units
â”‚   â””â”€â”€ unit.gd                     # MODIFY: Add ability usage tracking
â”‚
resources/
â””â”€â”€ abilities/
    â”œâ”€â”€ basic_attack.tres           # NEW: Basic Attack resource
    â”œâ”€â”€ power_attack.tres           # NEW: Power Attack resource
    â”œâ”€â”€ shield_bash.tres            # NEW: Shield Bash resource
    â””â”€â”€ rally.tres                  # NEW: Rally resource
```

### Script Responsibilities

**scripts/resources/ability.gd (NEW):**
- Define Ability resource class with properties
- Store ability metadata (name, description, icon)
- Define ability type (MELEE_ATTACK, BUFF, etc.)
- Store effect values (damage modifier, stun duration, buff amount)
- Track targeting requirements

**scripts/combat/ability_executor.gd (NEW):**
- Execute abilities based on type
- Apply damage with modifiers
- Apply status effects
- Handle targeting validation
- Emit signals for UI feedback

**scripts/combat/status_effect.gd (NEW):**
- Define status effect types (STUNNED, ATTACK_BUFF)
- Store effect properties (duration, value)

**scripts/combat/status_effect_manager.gd (NEW):**
- Track active effects on all units
- Decrement durations at turn end
- Remove expired effects
- Query effect modifiers for combat calculations

**scripts/combat/unit.gd (MODIFY):**
- Track ability usage per battle
- Query if ability is available
- Apply status effects to self
- Reset ability uses on battle start

### Detailed Script: ability.gd

```gdscript
## Ability - Resource class defining ability properties
## Part of: Blood & Gold Prototype
## Spec: docs/features/2.3-implement-player-abilities.md
class_name Ability
extends Resource

# ===== ENUMS =====
enum AbilityType {
	MELEE_ATTACK,       # Requires adjacent enemy target
	RANGED_ATTACK,      # Requires enemy in range (future)
	SELF_BUFF,          # Targets self (future)
	ALLY_BUFF,          # Targets ally (future)
	SOLDIER_BUFF,       # Targets all soldiers (Rally)
	AOE_ATTACK,         # Hits multiple targets (future)
}

enum TargetType {
	NONE,               # No target needed
	ENEMY_ADJACENT,     # Adjacent enemy
	ENEMY_RANGE,        # Enemy within range (future)
	ALLY,               # Friendly unit (future)
	SELF,               # Self only (future)
}

# ===== EXPORTED PROPERTIES =====
@export var id: String = ""
@export var display_name: String = ""
@export var description: String = ""
@export var icon: Texture2D = null

@export var ability_type: AbilityType = AbilityType.MELEE_ATTACK
@export var target_type: TargetType = TargetType.ENEMY_ADJACENT

# Usage limits
@export var uses_per_battle: int = -1  # -1 = unlimited
@export var ends_turn: bool = true     # Does using this end the turn?

# Combat modifiers
@export var damage_multiplier: float = 1.0      # 1.5 for Power Attack
@export var attack_modifier: int = 0            # -2 for Power Attack
@export var bonus_damage: int = 0               # Flat bonus damage

# Status effect application
@export var applies_status: String = ""         # "STUNNED", "ATTACK_BUFF", etc.
@export var status_duration: int = 0            # Turns
@export var status_value: int = 0               # +2 for attack buff, etc.

# Targeting
@export var range: int = 1                      # 1 = adjacent only
@export var targets_soldiers_only: bool = false # Rally targets soldiers
@export var requires_target: bool = true        # false for Rally

# ===== METHODS =====
func is_available_for_unit(unit: Unit) -> bool:
	## Check if this ability can be used by the unit
	# Check uses remaining
	if uses_per_battle > 0:
		var uses = unit.get_ability_uses(id)
		if uses >= uses_per_battle:
			return false

	# Check if there are valid targets (for targeted abilities)
	if requires_target:
		return _has_valid_targets(unit)

	return true

func _has_valid_targets(unit: Unit) -> bool:
	## Check if there are valid targets for this ability
	match target_type:
		TargetType.NONE:
			return true
		TargetType.ENEMY_ADJACENT:
			return _has_adjacent_enemies(unit)
		_:
			return true

func _has_adjacent_enemies(unit: Unit) -> bool:
	## Check if unit has adjacent enemies
	# Delegate to CombatManager for actual check
	return CombatManager.has_adjacent_enemies(unit)
```

### Detailed Script: ability_executor.gd

```gdscript
## AbilityExecutor - Executes ability effects
## Part of: Blood & Gold Prototype
## Spec: docs/features/2.3-implement-player-abilities.md
class_name AbilityExecutor
extends RefCounted

# ===== SIGNALS =====
signal ability_executed(user: Unit, ability: Ability, targets: Array[Unit])
signal damage_dealt(source: Unit, target: Unit, amount: int, is_ability: bool)
signal status_applied(target: Unit, status: String, duration: int, value: int)

# ===== STATIC METHODS =====
static func execute(user: Unit, ability: Ability, target: Unit = null) -> Dictionary:
	## Execute an ability and return results
	var result = {
		"success": false,
		"damage_dealt": 0,
		"status_applied": "",
		"targets_affected": [],
		"message": ""
	}

	# Mark ability as used
	if ability.uses_per_battle > 0:
		user.use_ability(ability.id)

	match ability.ability_type:
		Ability.AbilityType.MELEE_ATTACK:
			result = _execute_melee_attack(user, ability, target)
		Ability.AbilityType.SOLDIER_BUFF:
			result = _execute_soldier_buff(user, ability)
		_:
			push_error("[AbilityExecutor] Unknown ability type: %s" % ability.ability_type)

	return result

static func _execute_melee_attack(user: Unit, ability: Ability, target: Unit) -> Dictionary:
	## Execute a melee attack ability (Basic Attack, Power Attack, Shield Bash)
	var result = {
		"success": false,
		"damage_dealt": 0,
		"status_applied": "",
		"targets_affected": [target],
		"hit": false,
		"roll": 0,
		"total_attack": 0,
		"message": ""
	}

	if not target or not target.is_alive():
		result.message = "Invalid target"
		return result

	# Check adjacency
	if not AttackResolver.is_adjacent(user, target):
		result.message = "Target not adjacent"
		return result

	# Roll attack with ability modifier
	var attack_bonus = user.get_attack_bonus() + ability.attack_modifier
	result.roll = randi_range(1, 20)
	result.total_attack = result.roll + attack_bonus
	var target_defense = target.get_defense()

	# Check for hit
	result.hit = result.total_attack >= target_defense or result.roll == 20

	if result.hit:
		# Calculate damage with multiplier
		var base_damage = randi_range(1, user.get_damage_die()) + user.get_damage_modifier()
		var modified_damage = int(base_damage * ability.damage_multiplier) + ability.bonus_damage

		# Critical hit on natural 20
		if result.roll == 20:
			modified_damage *= 2

		result.damage_dealt = max(1, modified_damage)
		target.take_damage(result.damage_dealt)
		result.success = true

		# Apply status effect if ability has one and target still alive
		if not ability.applies_status.is_empty() and target.is_alive():
			StatusEffectManager.apply_effect(
				target,
				ability.applies_status,
				ability.status_duration,
				ability.status_value
			)
			result.status_applied = ability.applies_status

		result.message = "%s hits %s for %d damage" % [
			user.unit_name, target.unit_name, result.damage_dealt
		]
		if not result.status_applied.is_empty():
			result.message += " (applied %s)" % result.status_applied
	else:
		result.message = "%s misses %s" % [user.unit_name, target.unit_name]

	# Log combat
	print("[Combat] %s uses %s on %s" % [user.unit_name, ability.display_name, target.unit_name])
	print("[Combat] Attack roll: %d + %d = %d vs DEF %d -> %s" % [
		result.roll, attack_bonus, result.total_attack, target_defense,
		"HIT" if result.hit else "MISS"
	])
	if result.hit:
		print("[Combat] %s deals %d damage to %s" % [
			ability.display_name, result.damage_dealt, target.unit_name
		])
		if not result.status_applied.is_empty():
			print("[Combat] %s is %s for %d turn(s)" % [
				target.unit_name, result.status_applied, ability.status_duration
			])

	return result

static func _execute_soldier_buff(user: Unit, ability: Ability) -> Dictionary:
	## Execute a soldier buff ability (Rally)
	var result = {
		"success": true,
		"damage_dealt": 0,
		"status_applied": ability.applies_status,
		"targets_affected": [],
		"message": ""
	}

	# Get all friendly soldiers
	var soldiers = CombatManager.get_friendly_soldiers()

	for soldier in soldiers:
		if soldier.is_alive():
			StatusEffectManager.apply_effect(
				soldier,
				ability.applies_status,
				ability.status_duration,
				ability.status_value
			)
			result.targets_affected.append(soldier)

	result.message = "%s uses %s - %d soldiers gain +%d attack for %d turns" % [
		user.unit_name,
		ability.display_name,
		result.targets_affected.size(),
		ability.status_value,
		ability.status_duration
	]

	print("[Combat] %s uses %s" % [user.unit_name, ability.display_name])
	print("[Combat] %d soldiers gain +%d attack for %d turns" % [
		result.targets_affected.size(), ability.status_value, ability.status_duration
	])

	return result
```

### Detailed Script: status_effect_manager.gd

```gdscript
## StatusEffectManager - Manages status effects on all units
## Part of: Blood & Gold Prototype
## Spec: docs/features/2.3-implement-player-abilities.md
class_name StatusEffectManager
extends Node

# ===== EFFECT TYPES =====
const EFFECT_STUNNED = "STUNNED"
const EFFECT_ATTACK_BUFF = "ATTACK_BUFF"

# ===== SIGNALS =====
signal effect_applied(unit: Unit, effect_type: String, duration: int, value: int)
signal effect_removed(unit: Unit, effect_type: String)
signal effect_tick(unit: Unit, effect_type: String, remaining: int)

# ===== STATE =====
# Dictionary of unit -> Array of active effects
# Each effect: {type: String, duration: int, value: int}
var _effects: Dictionary = {}

# ===== LIFECYCLE =====
func _ready() -> void:
	# Connect to turn manager for tick processing
	CombatManager.turn_ended.connect(_on_turn_ended)
	print("[StatusEffectManager] Ready")

# ===== PUBLIC API =====
static func apply_effect(target: Unit, effect_type: String, duration: int, value: int = 0) -> void:
	## Apply a status effect to a unit
	var manager = _get_instance()
	if not manager:
		push_error("[StatusEffectManager] Manager not found!")
		return

	manager._apply_effect_internal(target, effect_type, duration, value)

static func has_effect(unit: Unit, effect_type: String) -> bool:
	## Check if unit has a specific effect
	var manager = _get_instance()
	if not manager:
		return false
	return manager._has_effect_internal(unit, effect_type)

static func get_effect_value(unit: Unit, effect_type: String) -> int:
	## Get the value of an effect (e.g., +2 attack from ATTACK_BUFF)
	var manager = _get_instance()
	if not manager:
		return 0
	return manager._get_effect_value_internal(unit, effect_type)

static func remove_effect(unit: Unit, effect_type: String) -> void:
	## Remove a specific effect from a unit
	var manager = _get_instance()
	if manager:
		manager._remove_effect_internal(unit, effect_type)

static func clear_all_effects() -> void:
	## Clear all effects (battle end)
	var manager = _get_instance()
	if manager:
		manager._effects.clear()
		print("[StatusEffectManager] All effects cleared")

static func _get_instance() -> StatusEffectManager:
	## Get the singleton instance
	var tree = Engine.get_main_loop()
	if tree and tree.root:
		return tree.root.get_node_or_null("/root/StatusEffectManager")
	return null

# ===== INTERNAL METHODS =====
func _apply_effect_internal(target: Unit, effect_type: String, duration: int, value: int) -> void:
	## Internal apply effect
	if not is_instance_valid(target):
		return

	var unit_id = target.get_instance_id()

	if not _effects.has(unit_id):
		_effects[unit_id] = []

	# Check if effect already exists (refresh duration)
	for effect in _effects[unit_id]:
		if effect.type == effect_type:
			effect.duration = max(effect.duration, duration)  # Refresh to longer duration
			effect.value = value  # Update value
			print("[StatusEffect] Refreshed %s on %s (%d turns)" % [effect_type, target.unit_name, duration])
			effect_applied.emit(target, effect_type, duration, value)
			return

	# Add new effect
	_effects[unit_id].append({
		"type": effect_type,
		"duration": duration,
		"value": value,
		"unit": target  # Weak reference for cleanup
	})

	print("[StatusEffect] Applied %s to %s for %d turns (value: %d)" % [
		effect_type, target.unit_name, duration, value
	])
	effect_applied.emit(target, effect_type, duration, value)

func _has_effect_internal(unit: Unit, effect_type: String) -> bool:
	## Check if unit has effect
	if not is_instance_valid(unit):
		return false

	var unit_id = unit.get_instance_id()
	if not _effects.has(unit_id):
		return false

	for effect in _effects[unit_id]:
		if effect.type == effect_type:
			return true
	return false

func _get_effect_value_internal(unit: Unit, effect_type: String) -> int:
	## Get effect value
	if not is_instance_valid(unit):
		return 0

	var unit_id = unit.get_instance_id()
	if not _effects.has(unit_id):
		return 0

	for effect in _effects[unit_id]:
		if effect.type == effect_type:
			return effect.value
	return 0

func _remove_effect_internal(unit: Unit, effect_type: String) -> void:
	## Remove specific effect
	if not is_instance_valid(unit):
		return

	var unit_id = unit.get_instance_id()
	if not _effects.has(unit_id):
		return

	for i in range(_effects[unit_id].size() - 1, -1, -1):
		if _effects[unit_id][i].type == effect_type:
			_effects[unit_id].remove_at(i)
			effect_removed.emit(unit, effect_type)
			print("[StatusEffect] Removed %s from %s" % [effect_type, unit.unit_name])
			return

func _on_turn_ended(unit: Unit) -> void:
	## Tick effects at end of unit's turn
	if not is_instance_valid(unit):
		return

	var unit_id = unit.get_instance_id()
	if not _effects.has(unit_id):
		return

	# Tick down durations and remove expired
	var effects_to_remove: Array[int] = []

	for i in range(_effects[unit_id].size()):
		var effect = _effects[unit_id][i]
		effect.duration -= 1

		if effect.duration <= 0:
			effects_to_remove.append(i)
			print("[StatusEffect] %s expired on %s" % [effect.type, unit.unit_name])
		else:
			effect_tick.emit(unit, effect.type, effect.duration)

	# Remove expired effects (reverse order to maintain indices)
	for i in range(effects_to_remove.size() - 1, -1, -1):
		var effect = _effects[unit_id][effects_to_remove[i]]
		effect_removed.emit(unit, effect.type)
		_effects[unit_id].remove_at(effects_to_remove[i])

	# Clean up empty arrays
	if _effects[unit_id].is_empty():
		_effects.erase(unit_id)
```

### Unit.gd Modifications

```gdscript
## Add to scripts/combat/unit.gd

# ===== ABILITY USAGE TRACKING =====
var _ability_uses: Dictionary = {}  # ability_id -> times used this battle

func reset_ability_uses() -> void:
	## Reset all ability uses (battle start/restart)
	_ability_uses.clear()

func use_ability(ability_id: String) -> void:
	## Mark an ability as used
	if not _ability_uses.has(ability_id):
		_ability_uses[ability_id] = 0
	_ability_uses[ability_id] += 1

func get_ability_uses(ability_id: String) -> int:
	## Get number of times ability has been used
	return _ability_uses.get(ability_id, 0)

func is_ability_available(ability_id: String) -> bool:
	## Check if an ability can be used (override for ability system integration)
	var ability = get_ability_by_id(ability_id)
	if ability:
		return ability.is_available_for_unit(self)
	return false

func get_ability_by_id(ability_id: String) -> Ability:
	## Get Ability resource by ID
	for ability_data in _abilities:
		if ability_data.get("id") == ability_id:
			var path = "res://resources/abilities/%s.tres" % ability_id
			if ResourceLoader.exists(path):
				return load(path) as Ability
	return null

# ===== STATUS EFFECT INTEGRATION =====
func is_stunned() -> bool:
	## Check if unit is currently stunned
	return StatusEffectManager.has_effect(self, StatusEffectManager.EFFECT_STUNNED)

func get_attack_buff() -> int:
	## Get attack buff value (for combat calculations)
	return StatusEffectManager.get_effect_value(self, StatusEffectManager.EFFECT_ATTACK_BUFF)

# Modify get_attack_bonus() to include buffs:
func get_attack_bonus() -> int:
	## Get appropriate attack bonus based on finesse property + buffs
	var base_bonus = 0
	if uses_finesse:
		base_bonus = get_ranged_attack_bonus()
	else:
		base_bonus = get_melee_attack_bonus()

	# Add attack buff if present
	base_bonus += get_attack_buff()

	return base_bonus
```

### TurnManager.gd Modifications

```gdscript
## Add to scripts/combat/turn_manager.gd in _start_current_turn()

func _start_current_turn() -> void:
	## Start the current unit's turn
	var unit = get_current_unit()
	if not unit:
		return

	# Check for stun - skip turn if stunned
	if unit.is_stunned():
		print("[TurnManager] %s is STUNNED - skipping turn" % unit.unit_name)
		# Remove stun after it takes effect
		StatusEffectManager.remove_effect(unit, StatusEffectManager.EFFECT_STUNNED)
		# Small delay for visual feedback
		await get_tree().create_timer(0.5).timeout
		end_current_turn()
		return

	print("[TurnManager] Turn %d: %s" % [_current_turn_index + 1, unit.unit_name])
	turn_started.emit(unit)

	# If enemy, auto-skip turn (placeholder for Phase 2 AI)
	if unit.is_enemy:
		print("[TurnManager] Enemy turn skipped (AI placeholder)")
		await get_tree().create_timer(ENEMY_TURN_DELAY).timeout
		end_current_turn()
```

### Ability Resource Files

**resources/abilities/basic_attack.tres:**
```
[gd_resource type="Resource" script_class="Ability" load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/resources/ability.gd" id="1"]

[resource]
script = ExtResource("1")
id = "basic_attack"
display_name = "Attack"
description = "A standard melee attack."
ability_type = 0  # MELEE_ATTACK
target_type = 1   # ENEMY_ADJACENT
uses_per_battle = -1  # Unlimited
ends_turn = true
damage_multiplier = 1.0
attack_modifier = 0
bonus_damage = 0
applies_status = ""
status_duration = 0
status_value = 0
range = 1
targets_soldiers_only = false
requires_target = true
```

**resources/abilities/power_attack.tres:**
```
[gd_resource type="Resource" script_class="Ability" load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/resources/ability.gd" id="1"]

[resource]
script = ExtResource("1")
id = "power_attack"
display_name = "Power Attack"
description = "A powerful strike. +50% damage, -2 to hit. Once per battle."
ability_type = 0  # MELEE_ATTACK
target_type = 1   # ENEMY_ADJACENT
uses_per_battle = 1
ends_turn = true
damage_multiplier = 1.5
attack_modifier = -2
bonus_damage = 0
applies_status = ""
status_duration = 0
status_value = 0
range = 1
targets_soldiers_only = false
requires_target = true
```

**resources/abilities/shield_bash.tres:**
```
[gd_resource type="Resource" script_class="Ability" load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/resources/ability.gd" id="1"]

[resource]
script = ExtResource("1")
id = "shield_bash"
display_name = "Shield Bash"
description = "Bash enemy with shield. Deals damage and stuns for 1 turn. Once per battle."
ability_type = 0  # MELEE_ATTACK
target_type = 1   # ENEMY_ADJACENT
uses_per_battle = 1
ends_turn = true
damage_multiplier = 1.0
attack_modifier = 0
bonus_damage = 0
applies_status = "STUNNED"
status_duration = 1
status_value = 0
range = 1
targets_soldiers_only = false
requires_target = true
```

**resources/abilities/rally.tres:**
```
[gd_resource type="Resource" script_class="Ability" load_steps=2 format=3]

[ext_resource type="Script" path="res://scripts/resources/ability.gd" id="1"]

[resource]
script = ExtResource("1")
id = "rally"
display_name = "Rally"
description = "Inspire your soldiers! All soldiers gain +2 attack for 2 turns. Once per battle."
ability_type = 4  # SOLDIER_BUFF
target_type = 0   # NONE
uses_per_battle = 1
ends_turn = true
damage_multiplier = 1.0
attack_modifier = 0
bonus_damage = 0
applies_status = "ATTACK_BUFF"
status_duration = 2
status_value = 2
range = 0
targets_soldiers_only = true
requires_target = false
```

### Integration Points

| System | Integration |
|--------|-------------|
| AbilityBar (Task 2.2) | Calls AbilityExecutor when ability button clicked |
| AttackResolver | AbilityExecutor uses similar damage calculation |
| TurnManager | Checks for stun before starting turn |
| Unit | Tracks ability uses, provides status effect queries |
| CombatManager | Provides helper methods for targeting |
| StatusEffectManager | NEW autoload for effect tracking |

### Hardcoded Values

| Value | Location | Amount |
|-------|----------|--------|
| Power Attack damage bonus | power_attack.tres | 50% (1.5x multiplier) |
| Power Attack hit penalty | power_attack.tres | -2 |
| Shield Bash stun duration | shield_bash.tres | 1 turn |
| Rally attack bonus | rally.tres | +2 |
| Rally duration | rally.tres | 2 turns |
| Uses per battle | Each .tres | 1 (except basic_attack: -1) |

---

## 7. Acceptance Criteria

| # | Criterion | Test Method |
|---|-----------|-------------|
| 1 | Power Attack deals 50% more damage | Attack with both Basic Attack and Power Attack, compare damage (Power should be ~1.5x) |
| 2 | Power Attack has -2 to hit | Check combat log shows reduced attack roll |
| 3 | Shield Bash stuns enemy | After hit, enemy skips their next turn |
| 4 | Rally buffs soldiers | Check soldier attack rolls show +2 bonus |
| 5 | Rally lasts 2 turns | Buff expires after 2 soldier turns |
| 6 | Special abilities once per battle | After using Power Attack, button grayed out |
| 7 | Basic Attack unlimited | Can use Basic Attack every turn |
| 8 | Stun visual indicator | Stunned enemy shows stun icon above head |
| 9 | Buff visual indicator | Buffed soldiers show buff icon above head |
| 10 | Abilities require valid targets | No adjacent enemy = attack abilities grayed out |

---

## 8. Testing Checklist

### Functional Tests
- [ ] Basic Attack deals weapon damage
- [ ] Power Attack deals 1.5x weapon damage
- [ ] Power Attack has -2 attack penalty
- [ ] Shield Bash deals damage and stuns
- [ ] Stunned enemy skips turn
- [ ] Rally buffs all friendly soldiers
- [ ] Rally buff lasts 2 turns
- [ ] Rally buff adds +2 to soldier attacks
- [ ] Special abilities become unavailable after use
- [ ] Basic Attack remains available after use

### Integration Tests
- [ ] Ability bar shows correct availability
- [ ] Used abilities gray out in UI
- [ ] Stunned enemies skip turn in turn order
- [ ] Buff expires correctly at turn end
- [ ] Battle restart resets ability uses
- [ ] Status effects cleared on battle end

### Edge Cases
- [ ] Power Attack on dying blow works
- [ ] Shield Bash on dying blow (no stun applied)
- [ ] Rally with no soldiers (uses ability, no effect)
- [ ] Multiple stuns don't stack (refresh duration)
- [ ] Attack buff doesn't stack (refresh duration)
- [ ] Status effect on unit that dies

### Visual Tests
- [ ] Stun icon visible above stunned unit
- [ ] Buff icon visible above buffed soldiers
- [ ] Icons fade/remove when effect expires
- [ ] Combat log shows ability usage correctly

---

## 9. Implementation Notes

### Approach Rationale

**Why Ability Resources?**
- Separates data from code
- Easy to tweak values without code changes
- Supports future ability expansion
- Consistent pattern for all party members

**Why StatusEffectManager as Autoload?**
- Global access needed for stun checks
- Persists across scenes
- Single source of truth for effects
- Easy cleanup on battle end

**Why once-per-battle instead of cooldowns?**
- Simpler for prototype scope
- Creates meaningful strategic decisions
- Avoids tracking turn counts per ability
- Matches GDD specification

### Gotchas to Watch

1. **Stun timing**: Stun is checked at turn START, not applied until after attack resolves
2. **Effect cleanup**: Must clear effects on battle end/restart
3. **Instance IDs**: Use unit instance IDs for effect tracking (not references)
4. **Buff application**: Rally only targets `is_soldier` units, not party members
5. **Turn order**: Stunned units should still appear in turn order UI (grayed)

### Alternative Approaches Considered

| Approach | Pros | Cons | Decision |
|----------|------|------|----------|
| Effects on Unit directly | Simpler | Unit script bloated | Rejected |
| **Separate StatusEffectManager** | Clean separation | More files | **Chosen** |
| Cooldown-based abilities | More tactical depth | Scope creep | Rejected for prototype |
| Ability scripts per ability | Custom logic | Too many files | Rejected |
| **Resource-based abilities** | Data-driven, extensible | Requires good base class | **Chosen** |

### Future Enhancements (Out of Scope)

- Ability tooltips with full descriptions
- Ability cooldowns (turns-based)
- Ability upgrades (Power Attack â†’ Devastating Blow)
- Status effect icons animated
- Buff/debuff stacking rules
- Resistance to status effects

---

## 10. Definition of Done

- [ ] `scripts/resources/ability.gd` created with all properties
- [ ] `scripts/combat/ability_executor.gd` implements all ability types
- [ ] `scripts/combat/status_effect_manager.gd` tracks effects
- [ ] `resources/abilities/basic_attack.tres` created
- [ ] `resources/abilities/power_attack.tres` created
- [ ] `resources/abilities/shield_bash.tres` created
- [ ] `resources/abilities/rally.tres` created
- [ ] Unit.gd modified for ability tracking and status queries
- [ ] TurnManager.gd checks for stun at turn start
- [ ] Power Attack deals 50% more damage with -2 hit penalty
- [ ] Shield Bash stuns target for 1 turn
- [ ] Rally buffs soldiers +2 attack for 2 turns
- [ ] Special abilities usable once per battle
- [ ] Basic Attack usable every turn
- [ ] Status effect icons visible above affected units
- [ ] Combat log shows ability usage
- [ ] All acceptance criteria pass
- [ ] Code follows GDScript style guidelines

---

## 11. References

### From GDD

- **Player Character Abilities** (Section 4: Party Members):
  - Power Attack: +50% damage, -2 hit
  - Shield Bash: stun 1 turn
  - Rally: soldiers +2 attack for 2 turns
- **Combat System** (Section 3):
  - Move + Action per turn
  - Attack resolution: d20 + modifiers vs Defense
- **Soldier Orders** (Section 3):
  - Soldiers are separate from party members

### From Roadmap

- **Task 2.3**: Implement Player Abilities (Phase 2, 2.5 hours)
- **What**: Player character's 4 abilities: Power Attack, Shield Bash, Rally, Basic Attack
- **Dependencies**: Task 2.2 (Ability UI Panel)
- **Files**: ability.gd, power_attack.tres, shield_bash.tres, rally.tres

### Related Tasks

- **Task 2.2**: Ability UI Panel (displays abilities)
- **Task 2.4**: Implement Thorne Abilities (uses same ability system)
- **Task 2.5**: Implement Lyra Abilities (uses same ability system)
- **Task 2.6**: Implement Matthias Abilities (uses same ability system)
- **Task 2.8**: Soldier Unit Type (affected by Rally)
