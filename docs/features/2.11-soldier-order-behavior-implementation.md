# Task 2.11: Soldier Order Behavior Implementation

**Status:** üü¢ Implemented
**Priority:** ‚¨ÜÔ∏è High
**Estimated Time:** 3 hours
**Dependencies:** Task 2.10 (Order UI Panel), Task 2.8 (Infantry), Task 2.9 (Archer)
**Assigned To:** AI assistant

---

## Purpose

**Why does this feature exist?**
The soldier order system is central to the "Build & Command" design pillar. Players should feel like mercenary commanders issuing strategic orders to their soldiers, not micromanagers controlling every unit. Each order creates distinct, observable soldier behavior that players can predict and plan around.

**What does it enable?**
- Five distinct tactical options for controlling soldiers (ADVANCE, HOLD, FOCUS_FIRE, RETREAT, PROTECT)
- Soldiers act autonomously based on orders, freeing players to focus on party tactics
- Emergent tactical combinations (e.g., HOLD infantry line with FOCUS_FIRE archers)
- Strategic depth through order selection and timing
- The "commanding a warband" fantasy described in the GDD

**Success criteria:**
- Each order produces visually distinct, predictable soldier behavior
- Players can observe soldiers following orders without direct control
- FOCUS_FIRE allows coordinated attacks on high-priority targets
- PROTECT keeps soldiers adjacent to designated ally, intercepting attacks
- RETREAT provides reliable escape route for damaged soldiers
- Order icons clearly communicate current order state

---

## How It Works

### Overview

Soldiers follow **standing orders** that determine their autonomous behavior each turn. The player assigns orders via the Order Panel (Task 2.10), and soldiers execute that order until given a new one. Each order creates distinct tactical opportunities:

**ADVANCE** - Aggressive pursuit. Soldiers move toward the nearest enemy and attack when adjacent. Best for pushing forward, breaking enemy lines, or chasing fleeing enemies.

**HOLD LINE** - Defensive position. Soldiers stay put and only attack enemies in their weapon range. Infantry attack adjacent enemies; archers shoot within 8 tiles. Best for holding chokepoints, protecting objectives, or maintaining formation.

**FOCUS FIRE** - Coordinated assault. All soldiers with this order attack the same designated target, even if other enemies are closer. Devastating for eliminating high-priority targets like enemy healers or commanders.

**RETREAT** - Tactical withdrawal. Soldiers move toward the starting map edge and don't attack. Best for preserving wounded soldiers or repositioning.

**PROTECT** - Bodyguard duty. Soldier stays adjacent to a designated ally and intercepts attacks targeting that ally. Best for keeping ranged characters or healers safe.

### User Flow

```
1. Player assigns order to soldier via Order Panel (Task 2.10)
2. Order icon above soldier updates to show new order
3. When soldier's turn arrives in initiative order:
   a. SoldierAI reads current_order property
   b. SoldierAI executes behavior for that order
   c. Turn ends automatically
4. Soldiers continue following same order until player changes it
5. Special cases:
   - FOCUS_FIRE: Requires designated target from CombatManager
   - PROTECT: Requires designated ally from CombatManager
```

### Rules & Constraints

**General Rules:**
- Orders persist until explicitly changed by player
- Soldiers act autonomously on their turn (no player input required)
- Soldiers always defend themselves if attacked (even on RETREAT)
- Dead soldiers are removed from turn order
- Soldier deaths don't trigger defeat condition (only party members do)

**ADVANCE Rules:**
- Move toward nearest enemy by tile distance
- Attack if adjacent (melee) or in range (ranged)
- If blocked, find alternate path
- If no enemies, stand idle

**HOLD LINE Rules:**
- Never move except for archer retreat behavior
- Attack any enemy in weapon range
- Infantry: Attack adjacent enemies only
- Archers: Shoot enemies within 8 tiles, retreat if adjacent
- If no targets in range, stand idle

**FOCUS FIRE Rules:**
- Attack designated target if in range
- If not in range, move toward designated target
- If designated target is dead, attack nearest enemy (fallback)
- If no designated target set, behave like ADVANCE

**RETREAT Rules:**
- Move toward starting map edge (Y=0 for player soldiers)
- Maximum movement per turn
- Do not attack (even if adjacent enemies)
- Self-defense exception: If attacked this turn, may counterattack next turn (optional)

**PROTECT Rules:**
- Stay within 1 tile of protected ally
- If not adjacent, move to adjacent tile
- If adjacent, attack enemies in weapon range
- **Attack Interception:** When protected ally would take damage, soldier may take damage instead (if adjacent)
- If protected ally dies, revert to HOLD behavior

### Edge Cases

- **ADVANCE: No path to enemy** - Move as close as possible, attack if in range
- **ADVANCE: Enemy behind ally** - Pathfind around, don't push through allies
- **HOLD: No targets** - Stand idle, don't move
- **HOLD: Enemy enters range** - Attack immediately
- **FOCUS_FIRE: Target out of range** - Move toward target until in range
- **FOCUS_FIRE: Target dead** - Attack nearest enemy (fallback to ADVANCE)
- **FOCUS_FIRE: No target designated** - Behave like ADVANCE
- **RETREAT: Blocked** - Find alternate path to edge, stand idle if completely blocked
- **RETREAT: At map edge** - Stand idle
- **PROTECT: Ally not adjacent** - Move to adjacent tile first
- **PROTECT: Multiple adjacent tiles open** - Choose tile nearest to enemies (to intercept)
- **PROTECT: Ally dead** - Revert to HOLD behavior
- **PROTECT: Attack interception** - Soldier takes damage instead of protected ally (once per round)

---

## User Interaction

### Controls

- **Order Assignment:** Via Order Panel (Task 2.10) - click order button, then click soldier
- **Target Designation (FOCUS_FIRE):** Click enemy after selecting FOCUS_FIRE order
- **Ally Designation (PROTECT):** Click ally after selecting PROTECT order
- **No direct soldier movement:** Soldiers cannot be moved manually (only via orders)

### Visual Feedback

- **Order Icon:** 24x24 icon above soldier showing current order
  - HOLD: Red shield icon
  - ADVANCE: Green sword icon
  - FOCUS_FIRE: Orange crosshair icon
  - RETREAT: Purple arrow icon
  - PROTECT: Blue shield-with-plus icon
- **Target Line (FOCUS_FIRE):** Faint red line from soldier to designated target
- **Protection Link (PROTECT):** Faint blue line from soldier to protected ally
- **Movement Path:** Standard movement path visualization when soldier moves
- **Attack Animation:** Standard attack feedback (damage numbers, flash)
- **Retreat Flash:** Brief orange tint when archer retreats (existing from Task 2.9)

### Audio Feedback (if applicable)

- Order assignment: Subtle UI click sound
- Order change: Voice line or sound effect indicating order type (future)
- Attack interception (PROTECT): Shield impact sound

---

## Visual Design

### Layout

```
Soldier Unit:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   [Order Icon]  ‚îÇ  <- 24x24 icon, color-coded by order
‚îÇ        ‚Üì        ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ   ‚îÇ  I / A  ‚îÇ   ‚îÇ  <- Unit sprite (Infantry/Archer)
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ   [===HP===]    ‚îÇ  <- HP bar below
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Order Icons:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇHOLD ‚îÇ ADV ‚îÇFOCUS‚îÇ RET ‚îÇPROT ‚îÇ
‚îÇüõ°Ô∏è   ‚îÇ ‚öîÔ∏è  ‚îÇ üéØ  ‚îÇ ‚Üê   ‚îÇ üõ°Ô∏è+ ‚îÇ
‚îÇ Red ‚îÇGreen‚îÇOrng ‚îÇPurp ‚îÇBlue ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Components

- **Order Icon Sprite:** 24x24 generated texture with color and symbol
- **Target Line (FOCUS_FIRE):** Line2D or draw call, red with low opacity
- **Protection Link (PROTECT):** Line2D or draw call, blue with low opacity

### Visual Style

Order icon colors (already defined in unit.gd):
| Order | Color | Hex |
|-------|-------|-----|
| HOLD | Red/Defensive | #e74c3c |
| ADVANCE | Green/Aggressive | #2ecc71 |
| FOCUS_FIRE | Orange/Targeted | #f39c12 |
| RETREAT | Purple/Withdraw | #9b59b6 |
| PROTECT | Blue/Guardian | #3498db |

### States

- **Default:** Order icon visible, soldier awaits turn
- **Taking Turn:** Order icon pulses, soldier executes order
- **Moving:** Movement animation plays
- **Attacking:** Attack animation plays
- **Intercepting (PROTECT):** Brief shield flash when taking damage for ally

---

## Technical Implementation

### Scene Structure

No new scenes needed. Modifications to existing:
```
Unit.tscn (existing)
‚îú‚îÄ‚îÄ Sprite2D
‚îú‚îÄ‚îÄ LetterLabel
‚îú‚îÄ‚îÄ HPBar
‚îú‚îÄ‚îÄ SelectionIndicator
‚îú‚îÄ‚îÄ ClickArea
‚îú‚îÄ‚îÄ OrderIcon (existing, already created in Task 2.8)
‚îî‚îÄ‚îÄ (optional) TargetLine - Line2D for FOCUS_FIRE/PROTECT visuals
```

### Script Responsibilities

**soldier_ai.gd (primary modifications):**
- `_execute_focus_fire_order(soldier, combat_grid)` - Attack designated target, move to range
- `_execute_retreat_order(soldier, combat_grid)` - Move toward starting edge
- `_execute_protect_order(soldier, combat_grid)` - Stay near ally, intercept attacks
- `_get_designated_target()` - Get FOCUS_FIRE target from CombatManager
- `_get_protected_ally()` - Get PROTECT target from CombatManager
- `_calculate_retreat_destination(soldier)` - Find best tile toward map edge
- `_find_protect_position(soldier, ally)` - Find adjacent tile to ally

**combat_manager.gd (additions):**
- `focus_fire_target: Unit` - Currently designated FOCUS_FIRE target
- `protected_allies: Dictionary` - Mapping of soldier -> protected ally
- `set_focus_fire_target(target: Unit)` - Designate FOCUS_FIRE target
- `set_protected_ally(soldier: Unit, ally: Unit)` - Designate PROTECT relationship
- `clear_focus_fire_target()` - Clear designation
- `get_focus_fire_target() -> Unit` - Get current target
- `get_protected_ally(soldier: Unit) -> Unit` - Get ally for specific soldier
- `intercept_attack(protected_ally: Unit, attacker: Unit, damage: int)` - Check for PROTECT interception

**unit.gd (may need additions):**
- `protected_by: Unit` - Reference to soldier protecting this unit (for interception)

### Integration Points

- **Connects to:** TurnManager (turn execution), CombatManager (target designation)
- **Emits signals:**
  - `order_executed(soldier, order_type)` - When order completes
  - `attack_intercepted(soldier, protected_ally, damage)` - When PROTECT triggers
- **Listens for:**
  - `TurnManager.turn_started` - Begin order execution
  - `CombatManager.focus_target_changed` - Update FOCUS_FIRE target
- **Modifies:**
  - Attack resolution flow (for PROTECT interception)

### Configuration

**Hardcoded Values:**
| Value | Amount | Notes |
|-------|--------|-------|
| Protect range | 1 tile | Soldier must be adjacent to protected ally |
| Retreat destination | Y=0 | Player soldiers retreat toward top of map |
| Attack interception chance | 100% | If adjacent, always intercept |
| Interception limit | 1/round | Each soldier can intercept once per round |

---

## Acceptance Criteria

Feature is complete when:

- [ ] ADVANCE: Soldier moves toward nearest enemy and attacks when adjacent/in range
- [ ] ADVANCE: Works for both infantry (melee) and archers (ranged)
- [ ] HOLD: Soldier stays in position and attacks enemies in weapon range
- [ ] HOLD: Infantry attack adjacent enemies only
- [ ] HOLD: Archers shoot enemies within 8 tiles
- [ ] FOCUS_FIRE: Soldier attacks designated target, ignoring closer enemies
- [ ] FOCUS_FIRE: Soldier moves toward target if not in range
- [ ] FOCUS_FIRE: Fallback to ADVANCE if no target designated or target dead
- [ ] RETREAT: Soldier moves toward starting map edge
- [ ] RETREAT: Soldier does not attack while retreating
- [ ] RETREAT: Soldier stops at map edge
- [ ] PROTECT: Soldier stays adjacent to designated ally
- [ ] PROTECT: Soldier attacks enemies in range while protecting
- [ ] PROTECT: Soldier intercepts attacks targeting protected ally (takes damage instead)
- [ ] Each order produces distinct, observable behavior
- [ ] Order icons correctly display current order
- [ ] Multiple soldiers can have different orders simultaneously

---

## Testing Checklist

### Functional Tests

- [ ] **ADVANCE Test:** Infantry advances toward enemy and attacks
- [ ] **ADVANCE Ranged Test:** Archer advances until in range, then shoots
- [ ] **HOLD Test:** Infantry stays put, attacks adjacent enemies
- [ ] **HOLD Ranged Test:** Archer stays put, shoots enemies in range
- [ ] **FOCUS_FIRE Test:** Soldiers attack designated target only
- [ ] **FOCUS_FIRE Range Test:** Soldier moves to get target in range
- [ ] **FOCUS_FIRE Fallback Test:** Soldier behaves like ADVANCE if target dead
- [ ] **RETREAT Test:** Soldier moves toward map edge
- [ ] **RETREAT No Attack Test:** Soldier doesn't attack while retreating
- [ ] **RETREAT Edge Test:** Soldier stops when reaching map edge
- [ ] **PROTECT Position Test:** Soldier moves to adjacent tile of ally
- [ ] **PROTECT Attack Test:** Soldier attacks while protecting
- [ ] **PROTECT Intercept Test:** Soldier takes damage for protected ally

### Edge Case Tests

- [ ] FOCUS_FIRE with no target designated
- [ ] PROTECT when ally dies
- [ ] RETREAT when path blocked
- [ ] Multiple soldiers with different orders in same battle
- [ ] Archer FOCUS_FIRE behavior
- [ ] Archer PROTECT behavior (ranged protection)

### Integration Tests

- [ ] Works with Order Panel (Task 2.10)
- [ ] Works with turn order system
- [ ] Works with damage number system
- [ ] Works with pathfinding
- [ ] Doesn't break party member controls
- [ ] Doesn't interfere with enemy AI

### Polish Tests

- [ ] Order icons update immediately when order changes
- [ ] FOCUS_FIRE target line visible
- [ ] PROTECT ally link visible
- [ ] Movement animations smooth
- [ ] Attack animations correct

---

## Implementation Notes

*(For AI assistant)*

### Key Considerations

1. **ADVANCE and HOLD already implemented:** Focus on FOCUS_FIRE, RETREAT, and PROTECT
2. **Use existing infrastructure:** SoldierAI already has order dispatch, just fill in methods
3. **CombatManager target tracking:** Add properties for FOCUS_FIRE target and PROTECT mappings
4. **Attack interception:** Modify damage resolution to check for PROTECT soldiers nearby

### Implementation Order

1. **RETREAT** (simplest) - Just move toward Y=0, don't attack
2. **FOCUS_FIRE** - Add target tracking to CombatManager, modify attack selection
3. **PROTECT** - Add ally mapping, position logic, attack interception

### RETREAT Implementation

```gdscript
static func _execute_retreat_order(soldier: Unit, combat_grid: CombatGrid) -> void:
    ## Move toward starting map edge (Y=0 for player soldiers)
    print("[SoldierAI] %s executing RETREAT order" % soldier.unit_name)

    # Calculate destination (toward Y=0)
    var current_pos = soldier.grid_position
    if current_pos.y == 0:
        print("[SoldierAI] %s already at map edge, standing idle" % soldier.unit_name)
        return

    # Find path toward Y=0
    var target_y = 0
    var target_x = current_pos.x  # Same column
    var destination = Vector2i(target_x, target_y)

    # Get path
    var path = combat_grid.pathfinding.get_path(current_pos, destination, soldier)
    if path.size() < 2:
        # Try nearby columns if direct path blocked
        for offset in [1, -1, 2, -2]:
            destination = Vector2i(target_x + offset, target_y)
            path = combat_grid.pathfinding.get_path(current_pos, destination, soldier)
            if path.size() >= 2:
                break

    if path.size() < 2:
        print("[SoldierAI] %s cannot retreat (no valid path)" % soldier.unit_name)
        return

    # Limit to movement range
    var limited_path = _limit_path_to_range(path, soldier.movement_range)
    soldier.move_along_path(limited_path)
    await soldier.movement_finished

    # DO NOT ATTACK - retreating soldiers don't engage
```

### FOCUS_FIRE Implementation

```gdscript
static func _execute_focus_fire_order(soldier: Unit, combat_grid: CombatGrid) -> void:
    ## Attack designated target, move to range if needed
    print("[SoldierAI] %s executing FOCUS_FIRE order" % soldier.unit_name)

    var target = CombatManager.get_focus_fire_target()
    if not target or not is_instance_valid(target) or not target.is_alive():
        print("[SoldierAI] No valid FOCUS_FIRE target, falling back to ADVANCE")
        await _execute_advance_order(soldier, combat_grid)
        return

    # Check if target in range
    var dist = _get_tile_distance(soldier.grid_position, target.grid_position)
    var in_range = dist <= soldier.weapon_range

    if soldier.is_ranged_weapon:
        # Ranged: Check range
        if in_range:
            soldier.perform_attack(target)
        else:
            # Move toward target
            await _move_toward_target(soldier, target, combat_grid)
            # Check again after move
            dist = _get_tile_distance(soldier.grid_position, target.grid_position)
            if dist <= soldier.weapon_range:
                soldier.perform_attack(target)
    else:
        # Melee: Must be adjacent
        if dist == 1:
            soldier.perform_attack(target)
        else:
            await _move_toward_target(soldier, target, combat_grid)
            if _get_tile_distance(soldier.grid_position, target.grid_position) == 1:
                soldier.perform_attack(target)
```

### PROTECT Implementation

```gdscript
static func _execute_protect_order(soldier: Unit, combat_grid: CombatGrid) -> void:
    ## Stay adjacent to protected ally, attack enemies in range
    print("[SoldierAI] %s executing PROTECT order" % soldier.unit_name)

    var ally = CombatManager.get_protected_ally(soldier)
    if not ally or not is_instance_valid(ally) or not ally.is_alive():
        print("[SoldierAI] No valid ally to protect, defaulting to HOLD")
        await _execute_hold_order(soldier, combat_grid)
        return

    var dist_to_ally = _get_tile_distance(soldier.grid_position, ally.grid_position)

    # Step 1: Move to adjacent position if not already
    if dist_to_ally > 1:
        var protect_pos = _find_protect_position(soldier, ally, combat_grid)
        if protect_pos != soldier.grid_position:
            var path = combat_grid.pathfinding.get_path(soldier.grid_position, protect_pos, soldier)
            if path.size() >= 2:
                var limited_path = _limit_path_to_range(path, soldier.movement_range)
                soldier.move_along_path(limited_path)
                await soldier.movement_finished

    # Step 2: Attack enemy in range (while protecting)
    var target: Unit = null
    if soldier.is_ranged_weapon:
        target = _find_target_in_range(soldier)
    else:
        target = _find_adjacent_enemy(soldier)

    if target:
        soldier.perform_attack(target)
    else:
        print("[SoldierAI] %s guarding %s (no enemies in range)" % [soldier.unit_name, ally.unit_name])

static func _find_protect_position(soldier: Unit, ally: Unit, combat_grid: CombatGrid) -> Vector2i:
    ## Find best adjacent tile to protected ally
    ## Prefer tiles between ally and nearest enemy
    var ally_pos = ally.grid_position
    var enemies = _get_all_enemies(soldier)

    # Get all adjacent tiles
    var adjacent_tiles = [
        ally_pos + Vector2i(1, 0),
        ally_pos + Vector2i(-1, 0),
        ally_pos + Vector2i(0, 1),
        ally_pos + Vector2i(0, -1),
        ally_pos + Vector2i(1, 1),
        ally_pos + Vector2i(-1, 1),
        ally_pos + Vector2i(1, -1),
        ally_pos + Vector2i(-1, -1),
    ]

    var best_pos = soldier.grid_position
    var best_score = -999.0

    for tile in adjacent_tiles:
        if not combat_grid.is_valid_position(tile):
            continue
        if combat_grid.is_occupied(tile) and tile != soldier.grid_position:
            continue

        # Score: prefer tiles closer to nearest enemy (to intercept)
        var min_enemy_dist = 999
        for enemy in enemies:
            var d = _get_tile_distance(tile, enemy.grid_position)
            min_enemy_dist = mini(min_enemy_dist, d)

        # Lower enemy distance = higher score (we want to be between ally and enemies)
        var score = -float(min_enemy_dist)

        if score > best_score:
            best_score = score
            best_pos = tile

    return best_pos
```

### Attack Interception (PROTECT)

Add to attack resolution flow in CombatManager or AttackResolver:
```gdscript
func resolve_attack(attacker: Unit, target: Unit) -> AttackResult:
    # Check for PROTECT interception
    var protector = get_protector_for_unit(target)
    if protector and is_instance_valid(protector) and protector.is_alive():
        var dist = _get_tile_distance(protector.grid_position, target.grid_position)
        if dist <= 1 and not protector.has_intercepted_this_round:
            # Protector intercepts the attack
            print("[Combat] %s intercepts attack on %s!" % [protector.unit_name, target.unit_name])
            protector.has_intercepted_this_round = true
            target = protector  # Redirect damage to protector

    # Continue with normal attack resolution
    ...
```

### Dependencies on Other Tasks

- **Task 2.10 (Order Panel):** UI for assigning orders and designating targets
- **Task 2.8/2.9:** Existing HOLD and ADVANCE implementations

---

## Hardcoded Values Reference

| Value | Amount | Notes |
|-------|--------|-------|
| Protect range | 1 tile | Soldier must be adjacent to protected ally |
| Retreat destination Y | 0 | Player soldiers retreat toward top of map |
| Enemy retreat destination Y | Grid height - 1 | Enemy soldiers retreat toward bottom |
| Attack interception distance | 1 tile | Must be adjacent to intercept |
| Interception limit | 1 per round | Each soldier can intercept once per combat round |
| FOCUS_FIRE fallback | ADVANCE | If no valid target |
| PROTECT fallback | HOLD | If protected ally dead |

---
