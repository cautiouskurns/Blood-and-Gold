# Feature Spec: Turn System Framework

| Property | Value |
|----------|-------|
| **Feature ID** | 1.8 |
| **Status** | ðŸ”´ Planned |
| **Priority** | ðŸ”¥ Critical |
| **Estimated Time** | 2 hours |
| **Phase** | Phase 1: Combat Visuals & Basic Interaction |
| **Dependencies** | Task 1.6 (Turn Order UI Panel), Task 1.7 (Basic Melee Attack Action) |

---

## 1. Purpose

### Why This Feature Exists

Turn-based tactical combat requires a structured system to manage whose turn it is, what actions are allowed, and when turns transition. Without a turn system, the game cannot enforce the "move + action" combat loop defined in the GDD. The Turn System Framework is the orchestrator that connects unit selection, movement, attacking, and the turn order UI into a cohesive gameplay experience. It directly enables the **Tactical Combat** design pillar by ensuring players and enemies take discrete, meaningful turns.

### What It Enables

- Structured combat flow where each unit acts in initiative order
- Clear turn phases: waiting for input â†’ executing movement â†’ executing action â†’ ending turn
- Automatic turn advancement after a unit completes their action
- Integration with Turn Order UI (Task 1.6) for visual feedback
- Foundation for enemy AI turns (Phase 2) with placeholder skip behavior
- Prevention of out-of-turn actions (can't move or attack when not your turn)
- Full rotation through all units before returning to first unit

### Success Criteria

| Criterion | Measurement |
|-----------|-------------|
| Initiative determines turn order | Units with higher d20 + DEX act first |
| Turn state enforcement | Player can only act during their turn |
| Turn completion | Turn advances automatically after action |
| Full rotation | All units get one turn per round |
| UI synchronization | Turn Order Panel highlights current unit |
| Grid synchronization | Current unit highlighted on grid |

---

## 2. Design Pillar Alignment

| Pillar | How This Feature Supports It |
|--------|------------------------------|
| **Tactical Combat** | Turn-based structure allows thoughtful decision-making. Players can plan their move and action knowing exactly when enemies will respond. |
| **Build & Command** | Clear turn structure distinguishes party control (player decides) from soldier/enemy turns (AI or placeholder behavior). |
| **Meaningful Choice** | Each turn is a discrete decision point - move where? Attack whom? Use which ability? Turn structure frames these choices. |

---

## 3. How It Works

### Overview

The Turn System Framework manages combat flow through two key components: a **TurnManager** that handles sequencing and a state machine within **CombatManager** that tracks turn phases.

At battle start, initiative is rolled for all units using `d20 + DEX modifier`. Units are sorted in descending order (highest initiative acts first). The Turn Order Panel (Task 1.6) is initialized with this sorted list.

Each unit's turn follows a state machine:
1. **WaitingForInput** - Turn starts, unit is highlighted, player can select actions
2. **Moving** - Unit is executing movement animation (from Task 1.5)
3. **Acting** - Unit is executing an action (attack from Task 1.7)
4. **TurnEnd** - Action complete, preparing to advance to next unit

When a unit's turn ends (after completing an action OR choosing to skip), the TurnManager advances to the next unit in initiative order. If all units have acted, a new round begins (currently just continues from top of order).

Enemy units automatically skip their turn in Phase 1 (placeholder - AI comes in Phase 2). This allows the turn system to be tested and validated without enemy AI complexity.

### User Flow

```
1. Battle starts
2. Initiative rolled for all units (d20 + DEX modifier)
3. Units sorted by initiative (highest first, ties favor friendly units)
4. Turn Order Panel populated (Task 1.6)
5. First unit's turn begins:
   a. CombatManager state â†’ WaitingForInput
   b. Current unit highlighted on grid (selection indicator)
   c. Turn Order Panel highlights current unit (gold border)
   d. If enemy: Auto-skip to step 7 (placeholder for Phase 2 AI)
   e. If player/party: Wait for player input
6. Player takes action:
   a. Move (optional): State â†’ Moving, wait for movement complete
   b. Attack/Ability (ends turn): State â†’ Acting, wait for action complete
7. Turn ends:
   a. State â†’ TurnEnd
   b. Clear movement highlights
   c. Advance to next unit in initiative order
   d. If all units have acted, start new round (repeat from step 5 with same order)
8. Repeat until battle ends (victory/defeat from Task 1.9)
```

### Turn State Machine

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  WaitingForInput â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚          â”‚                  â”‚          â”‚
         â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
         â”‚                   â”‚                    â”‚
         â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”             â”‚
         â”‚            â–¼             â–¼             â”‚
         â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
         â”‚     â”‚  Moving  â”‚â”€â”€â–¶â”‚  Acting  â”‚        â”‚
         â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â”‚
         â”‚            â”‚            â”‚              â”‚
         â”‚            â”‚ (move only)â”‚ (action)     â”‚
         â”‚            â–¼            â–¼              â”‚
         â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
         â”‚     â”‚       TurnEnd          â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   (next unit)
         â”‚                  â”‚
         â”‚                  â”‚ (same unit, no action yet)
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Rules & Constraints

| Rule | Description |
|------|-------------|
| One turn at a time | Only one unit can be in active turn state |
| Move + Action | Each turn allows one move and one action |
| Action ends turn | Using attack/ability immediately ends the turn |
| Move is optional | Units can act without moving first |
| Skip is allowed | Units can end turn without acting (future: End Turn button) |
| Initiative is fixed | Turn order doesn't change during battle (except deaths) |
| Enemies skip | Enemy turns auto-advance in Phase 1 (placeholder) |

### Edge Cases

| Scenario | Behavior |
|----------|----------|
| Unit dies during their turn | Turn ends immediately, advance to next living unit |
| Unit dies before their turn | Removed from turn order, never gets turn |
| All enemies die | Battle ends in victory (Task 1.9), turn system stops |
| All party dies | Battle ends in defeat (Task 1.9), turn system stops |
| Only one unit remains | That unit still takes turns (solo combat) |
| Tie initiative | Friendly units act before enemies at same value |
| Stunned unit (future) | Turn is skipped automatically |

---

## 4. User Interaction

### Controls

| Input | Action | State Required |
|-------|--------|----------------|
| Click unit | Select (if current turn unit) | WaitingForInput |
| Click tile | Move to tile | WaitingForInput, unit selected |
| Click enemy | Attack enemy (if adjacent) | WaitingForInput, unit selected |
| Click ability | Use ability (Task 2.x) | WaitingForInput, unit selected |
| End Turn button (future) | Skip action, end turn | WaitingForInput |

### Visual Feedback

| State | Visual |
|-------|--------|
| WaitingForInput | Current unit has selection indicator, movement range shown |
| Moving | Unit animating along path, movement tiles cleared |
| Acting | Attack animation playing, damage numbers appearing |
| TurnEnd | Brief pause, then transition to next unit |
| Not your turn | Unit selection disabled, no movement range shown |

### Audio Feedback (Future)

| Event | Sound |
|-------|-------|
| Turn start (player) | Subtle "your turn" chime |
| Turn start (enemy) | Different tone or silence |
| Turn end | Brief transition sound |

*Note: Audio is out of scope for prototype but noted for future.*

---

## 5. Visual Design

### Current Turn Indicators

The current turn unit receives multiple visual indicators:

1. **Turn Order Panel** (Task 1.6): Gold border on leftmost icon
2. **Grid Highlight**: Selection indicator on grid (yellow #f1c40f from Task 1.4)
3. **Movement Range**: Valid tiles highlighted (green from Task 1.5)

### Turn Transition

When turn advances:
1. Previous unit's selection indicator removed
2. Movement range overlay cleared
3. Turn Order Panel animates (icon slides out)
4. New current unit automatically selected (if party member)
5. New unit's movement range displayed

### State Display (Debug)

For development, display current state in console:
```
[TurnManager] Battle started - 7 units
[TurnManager] Initiative order: Lyra (18), Player (15), Bandit 1 (14), ...
[TurnManager] Turn 1: Player (WaitingForInput)
[TurnManager] Player -> Moving
[TurnManager] Player -> Acting (attack)
[TurnManager] Turn ended: Player
[TurnManager] Turn 2: Thorne (WaitingForInput)
```

---

## 6. Technical Implementation

### Scene Structure

No new scenes required. Turn system is logic-only, managed through scripts.

### Script Responsibilities

**scripts/combat/turn_manager.gd (NEW):**
- Roll initiative for all units at battle start
- Maintain sorted turn order list
- Track current turn index
- Advance turn to next unit
- Emit signals for turn events
- Handle round cycling (when all units have acted)

**scripts/autoload/combat_manager.gd (MODIFY):**
- Add turn state machine (enum TurnState)
- Track current state transitions
- Enforce action restrictions based on state
- Coordinate with TurnManager for turn flow
- Handle movement/action completion callbacks

### Detailed Script: turn_manager.gd

```gdscript
## TurnManager - Manages combat turn order and sequencing
## Part of: Blood & Gold Prototype
## Spec: docs/features/1.8-turn-system-framework.md
class_name TurnManager
extends Node

# ===== SIGNALS =====
signal battle_started(units: Array[Unit])
signal turn_started(unit: Unit)
signal turn_ended(unit: Unit)
signal round_started(round_number: int)
signal round_ended(round_number: int)

# ===== CONSTANTS =====
const D20_MIN: int = 1
const D20_MAX: int = 20

# ===== DEX MODIFIERS (from GDD) =====
const DEX_MODIFIERS: Dictionary = {
	Unit.UnitType.PLAYER: 1,      # DEX 12 = +1
	Unit.UnitType.THORNE: 0,      # DEX 10 = +0
	Unit.UnitType.LYRA: 3,        # DEX 16 = +3
	Unit.UnitType.MATTHIAS: 0,    # DEX 10 = +0
	Unit.UnitType.ENEMY: 1,       # Bandits DEX 12 = +1
	Unit.UnitType.INFANTRY: 0,    # DEX 10 = +0
	Unit.UnitType.ARCHER: 1,      # DEX 12 = +1
}

# ===== STATE =====
var _turn_order: Array[Unit] = []
var _current_turn_index: int = 0
var _current_round: int = 0
var _is_battle_active: bool = false

# ===== LIFECYCLE =====
func _ready() -> void:
	print("[TurnManager] Ready")

# ===== PUBLIC API =====
func start_battle(units: Array[Unit]) -> void:
	## Initialize turn order and start combat
	if units.is_empty():
		push_error("[TurnManager] Cannot start battle with no units")
		return

	_is_battle_active = true
	_current_round = 1
	_roll_initiative(units)

	print("[TurnManager] Battle started - %d units" % _turn_order.size())
	_print_initiative_order()

	battle_started.emit(_turn_order.duplicate())
	round_started.emit(_current_round)

	# Start first turn
	_current_turn_index = 0
	_start_current_turn()

func end_current_turn() -> void:
	## End the current unit's turn and advance to next
	if not _is_battle_active:
		return

	var current_unit = get_current_unit()
	if current_unit:
		print("[TurnManager] Turn ended: %s" % current_unit.unit_name)
		turn_ended.emit(current_unit)

	_advance_to_next_turn()

func remove_unit(unit: Unit) -> void:
	## Remove a unit from turn order (death)
	var index = _turn_order.find(unit)
	if index == -1:
		return

	_turn_order.remove_at(index)
	print("[TurnManager] Removed from turn order: %s" % unit.unit_name)

	# Adjust current index if needed
	if index < _current_turn_index:
		_current_turn_index -= 1
	elif index == _current_turn_index:
		# Current unit died, don't increment index (next unit will be at same index)
		_current_turn_index = mini(_current_turn_index, _turn_order.size() - 1)
		# If battle still active, start next turn
		if _is_battle_active and not _turn_order.is_empty():
			_start_current_turn()

func end_battle() -> void:
	## End combat completely
	_is_battle_active = false
	round_ended.emit(_current_round)
	print("[TurnManager] Battle ended after %d rounds" % _current_round)

func get_current_unit() -> Unit:
	## Get the unit whose turn it currently is
	if _turn_order.is_empty() or _current_turn_index >= _turn_order.size():
		return null
	return _turn_order[_current_turn_index]

func get_turn_order() -> Array[Unit]:
	## Get the current turn order
	return _turn_order.duplicate()

func is_battle_active() -> bool:
	return _is_battle_active

func get_current_round() -> int:
	return _current_round

# ===== INTERNAL METHODS =====
func _roll_initiative(units: Array[Unit]) -> void:
	## Roll initiative for all units and sort by result
	var initiative_rolls: Array[Dictionary] = []

	for unit in units:
		if not is_instance_valid(unit) or not unit.is_alive():
			continue

		var dex_mod = DEX_MODIFIERS.get(unit.unit_type, 0)
		var roll = randi_range(D20_MIN, D20_MAX)
		var total = roll + dex_mod

		initiative_rolls.append({
			"unit": unit,
			"roll": roll,
			"modifier": dex_mod,
			"total": total
		})

		print("[TurnManager] %s rolled %d + %d (DEX) = %d" % [
			unit.unit_name, roll, dex_mod, total
		])

	# Sort by total (descending), with friendly units winning ties
	initiative_rolls.sort_custom(_compare_initiative)

	# Extract sorted units
	_turn_order.clear()
	for data in initiative_rolls:
		_turn_order.append(data["unit"])

func _compare_initiative(a: Dictionary, b: Dictionary) -> bool:
	## Compare initiative rolls (higher goes first, friendly wins ties)
	if a["total"] != b["total"]:
		return a["total"] > b["total"]

	# Tie-breaker: friendly units go before enemies
	var a_friendly = a["unit"].is_friendly()
	var b_friendly = b["unit"].is_friendly()
	if a_friendly != b_friendly:
		return a_friendly  # true if a is friendly, false if b is friendly

	# Still tied: random (use unit name as stable tie-breaker)
	return a["unit"].unit_name < b["unit"].unit_name

func _advance_to_next_turn() -> void:
	## Move to the next unit in turn order
	_current_turn_index += 1

	# Check if round is complete
	if _current_turn_index >= _turn_order.size():
		_current_turn_index = 0
		round_ended.emit(_current_round)
		_current_round += 1
		round_started.emit(_current_round)
		print("[TurnManager] === Round %d ===" % _current_round)

	_start_current_turn()

func _start_current_turn() -> void:
	## Start the current unit's turn
	var unit = get_current_unit()
	if not unit:
		return

	print("[TurnManager] Turn %d: %s" % [_current_turn_index + 1, unit.unit_name])
	turn_started.emit(unit)

	# If enemy, auto-skip turn (placeholder for Phase 2 AI)
	if unit.is_enemy:
		print("[TurnManager] Enemy turn skipped (AI placeholder)")
		# Small delay before ending enemy turn for visual feedback
		await get_tree().create_timer(0.3).timeout
		end_current_turn()

func _print_initiative_order() -> void:
	## Debug print the initiative order
	var order_str = "Initiative order: "
	for i in range(_turn_order.size()):
		if i > 0:
			order_str += ", "
		order_str += _turn_order[i].unit_name
	print("[TurnManager] %s" % order_str)
```

### CombatManager State Machine Addition

```gdscript
## Add to scripts/autoload/combat_manager.gd

# ===== TURN STATE ENUM =====
enum TurnState {
	INACTIVE,        # No battle active
	WAITING_FOR_INPUT,  # Current unit can act
	MOVING,          # Unit is moving
	ACTING,          # Unit is performing action
	TURN_END         # Turn is ending
}

# ===== TURN STATE =====
var _turn_state: TurnState = TurnState.INACTIVE
var _current_turn_unit: Unit = null
var _turn_manager: TurnManager = null

# ===== SIGNALS =====
signal turn_state_changed(old_state: TurnState, new_state: TurnState)

# ===== TURN STATE MANAGEMENT =====
func set_turn_state(new_state: TurnState) -> void:
	var old_state = _turn_state
	_turn_state = new_state
	turn_state_changed.emit(old_state, new_state)
	print("[CombatManager] State: %s -> %s" % [
		TurnState.keys()[old_state],
		TurnState.keys()[new_state]
	])

func get_turn_state() -> TurnState:
	return _turn_state

func is_waiting_for_input() -> bool:
	return _turn_state == TurnState.WAITING_FOR_INPUT

func can_unit_act(unit: Unit) -> bool:
	## Check if a unit is allowed to act right now
	if _turn_state != TurnState.WAITING_FOR_INPUT:
		return false
	return unit == _current_turn_unit

# ===== TURN MANAGER INTEGRATION =====
func start_battle(units: Array[Unit]) -> void:
	_turn_manager = TurnManager.new()
	add_child(_turn_manager)

	_turn_manager.turn_started.connect(_on_turn_started)
	_turn_manager.turn_ended.connect(_on_turn_ended)

	_turn_manager.start_battle(units)

func end_current_turn() -> void:
	if _turn_manager:
		_turn_manager.end_current_turn()

func _on_turn_started(unit: Unit) -> void:
	_current_turn_unit = unit

	# Auto-select if friendly unit
	if unit.is_friendly():
		select_unit(unit)
		set_turn_state(TurnState.WAITING_FOR_INPUT)
	else:
		set_turn_state(TurnState.WAITING_FOR_INPUT)  # Enemy turn handled by TurnManager

func _on_turn_ended(unit: Unit) -> void:
	set_turn_state(TurnState.TURN_END)
	_current_turn_unit = null
	deselect_unit()

# ===== MOVEMENT INTEGRATION =====
func start_unit_movement(unit: Unit, path: Array) -> void:
	if not can_unit_act(unit):
		print("[CombatManager] Unit cannot move - not their turn")
		return

	set_turn_state(TurnState.MOVING)
	# ... existing movement code ...

func _on_unit_movement_finished(unit: Unit) -> void:
	# After moving, return to waiting for action input
	if _current_turn_unit == unit:
		set_turn_state(TurnState.WAITING_FOR_INPUT)

# ===== ACTION INTEGRATION =====
func start_unit_action(unit: Unit, action_type: String, target: Unit) -> void:
	if not can_unit_act(unit):
		print("[CombatManager] Unit cannot act - not their turn")
		return

	set_turn_state(TurnState.ACTING)
	# ... perform action ...

func _on_action_completed(unit: Unit) -> void:
	# Action ends the turn
	if _turn_manager:
		_turn_manager.end_current_turn()
```

### Integration Points

| System | Integration |
|--------|-------------|
| TurnOrderPanel (Task 1.6) | Receives sorted unit list, listens for turn_started to update highlight |
| Unit Selection (Task 1.4) | Only allows selection of current turn unit |
| Movement (Task 1.5) | Movement triggers state change, completion returns to WaitingForInput |
| Attack (Task 1.7) | Attack triggers state change to Acting, completion ends turn |
| Victory/Defeat (Task 1.9) | Calls end_battle() when conditions met |
| Main.gd | Initializes battle with unit array, connects signals |

### Signals

| Signal | Emitter | Parameters | Purpose |
|--------|---------|------------|---------|
| `battle_started` | TurnManager | `(units: Array[Unit])` | Battle beginning, UI setup |
| `turn_started` | TurnManager | `(unit: Unit)` | New unit's turn begins |
| `turn_ended` | TurnManager | `(unit: Unit)` | Unit's turn complete |
| `round_started` | TurnManager | `(round: int)` | New round of turns begins |
| `round_ended` | TurnManager | `(round: int)` | All units have acted this round |
| `turn_state_changed` | CombatManager | `(old: TurnState, new: TurnState)` | State machine transition |

---

## 7. File Structure

```
scripts/
â”œâ”€â”€ combat/
â”‚   â””â”€â”€ turn_manager.gd           # NEW: Turn sequencing logic
â””â”€â”€ autoload/
    â””â”€â”€ combat_manager.gd         # MODIFY: Add state machine
```

No new scenes required - this is a logic-only feature.

---

## 8. Acceptance Criteria

| # | Criterion | Test Method |
|---|-----------|-------------|
| 1 | Initiative rolled at battle start | Check console for roll values |
| 2 | Units sorted by initiative (highest first) | Verify Turn Order Panel order matches rolls |
| 3 | Current turn unit highlighted in Turn Order Panel | Gold border on correct icon |
| 4 | Current turn unit highlighted on grid | Selection indicator visible |
| 5 | Turn advances after player acts | Attack enemy, verify next unit becomes active |
| 6 | Can complete full rotation through all units | Let all units act, verify return to first |
| 7 | Enemy turns skip automatically | Enemy icons pass quickly without player input |
| 8 | Dead units removed from turn order | Kill unit, verify they don't get turns |
| 9 | Cannot act when not your turn | Try clicking other units, verify no response |
| 10 | Movement doesn't end turn | Move, verify can still attack |

---

## 9. Testing Checklist

### Functional Tests
- [ ] Battle starts with initiative rolls displayed in console
- [ ] Turn order matches initiative (highest first)
- [ ] First unit's turn starts automatically
- [ ] Friendly unit turns wait for player input
- [ ] Enemy unit turns skip automatically (0.3s delay)
- [ ] Moving changes state to Moving
- [ ] Movement completion returns to WaitingForInput
- [ ] Attack changes state to Acting
- [ ] Attack completion advances turn
- [ ] Full round cycles through all units
- [ ] Second round starts after all units act
- [ ] Battle can be ended externally

### Integration Tests
- [ ] Turn Order Panel highlights correct unit
- [ ] Selection indicator appears on current turn unit
- [ ] Movement range shows for current turn unit only
- [ ] Attack works during player turn
- [ ] Attack fails when not your turn
- [ ] Dead unit removed from turn order immediately
- [ ] Dead unit doesn't get subsequent turns

### Edge Cases
- [ ] Battle with single unit
- [ ] All enemies die mid-round
- [ ] Current unit dies during their turn
- [ ] Initiative tie (friendly before enemy)
- [ ] Very high vs very low DEX modifiers

### State Machine Tests
- [ ] State transitions logged correctly
- [ ] Cannot move while in Acting state
- [ ] Cannot attack while in Moving state
- [ ] State returns to WaitingForInput after move
- [ ] State goes to TurnEnd after action

---

## 10. Implementation Notes

### Approach Rationale

**Why separate TurnManager from CombatManager?**
- Single responsibility: TurnManager handles sequence, CombatManager handles state
- TurnManager can be easily reset for new battles
- Cleaner signal organization
- Easier to unit test independently

**Why a state machine?**
- Prevents invalid actions (attacking while moving)
- Clear visual feedback mapping (state â†’ UI)
- Easier to debug (state logged)
- Extensible for future states (Targeting, Casting, etc.)

**Why auto-skip enemy turns?**
- Allows turn system testing without AI complexity
- Phase 2 will replace skip with actual AI
- Maintains turn flow and round structure
- Shows system working end-to-end

### Gotchas to Watch

1. **Unit validity**: Always check `is_instance_valid()` before accessing unit properties
2. **Signal timing**: Ensure signals emit after state is updated, not before
3. **Async movement**: Movement is async (tweens) - must wait for completion
4. **Round boundaries**: Index wraps to 0, must handle carefully
5. **Death during turn**: Current unit dying requires special handling

### Alternative Approaches Considered

| Approach | Pros | Cons | Decision |
|----------|------|------|----------|
| Single CombatManager class | Simpler, fewer files | Gets complex, hard to test | Rejected |
| **Separate TurnManager** | Clean separation, testable | Two classes to coordinate | **Chosen** |
| Timer-based turns | Real-time feel | Not turn-based per spec | Rejected |
| No state machine | Simpler | Hard to prevent invalid actions | Rejected |

### Dependencies on Previous Tasks

- **Task 1.6 (Turn Order Panel)**: Must exist to display turn order
- **Task 1.7 (Attack Action)**: Action completion triggers turn end
- **Task 1.4 (Selection)**: Selection tied to current turn unit
- **Task 1.5 (Movement)**: Movement state tracking needed

### Future Enhancements (Out of Scope)

- End Turn button (skip without acting)
- Delay action (act later in turn order)
- Ready action (interrupt enemy)
- Status effect handling (stun skips turn)
- Multi-action abilities
- Bonus actions

---

## 11. Definition of Done

- [ ] `scripts/combat/turn_manager.gd` created with full implementation
- [ ] `scripts/autoload/combat_manager.gd` updated with state machine
- [ ] Initiative rolled at battle start (d20 + DEX)
- [ ] Units sorted by initiative descending
- [ ] Friendly units win initiative ties
- [ ] Current turn unit highlighted in Turn Order Panel
- [ ] Current turn unit auto-selected on grid
- [ ] Player can move and attack during turn
- [ ] Attack ends turn and advances to next unit
- [ ] Enemy turns skip with 0.3s delay
- [ ] Full rotation through all units works
- [ ] Dead units removed from turn order
- [ ] All acceptance criteria pass
- [ ] Console logging shows turn flow clearly
- [ ] Code follows GDScript style guidelines

---

## 12. References

### From GDD

- **Turn Order**: "Initiative rolled (d20 + DEX modifier) determines turn order" (Section 3: Combat System)
- **Turn Structure**: "On each unit's turn: Move (up to movement speed) + Action (attack/ability/item)" (Section 3)
- **DEX Modifiers**: Player +1, Thorne +0, Lyra +3, Matthias +0, Bandits +1 (Section 4: Party Members)
- **Combat State**: "State machine (Idle â†’ Selected â†’ Moving â†’ Acting â†’ Done)" (Section 10: Technical Notes)

### From Roadmap

- **Task 1.8**: Turn System Framework (Phase 1, Day 2, 2 hours)
- **Dependencies**: Task 1.6 (Turn Order UI), Task 1.7 (Attack Action)
- **Hardcoded Values**: Initiative d20 + DEX, Player DEX +1, Bandit DEX +1
- **Key Signals**: `turn_ended(unit)` listed in Technical Notes

### Godot Documentation

- [Node lifecycle](https://docs.godotengine.org/en/stable/tutorials/best_practices/node_lifecycle.html)
- [Signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html)
- [Async/await](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#awaiting-for-signals-or-coroutines)
- [State machines](https://docs.godotengine.org/en/stable/tutorials/best_practices/state_machine.html)
