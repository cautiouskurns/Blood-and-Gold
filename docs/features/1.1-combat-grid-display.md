# Feature Spec: Combat Grid Display

| Property | Value |
|----------|-------|
| **Feature ID** | 1.1 |
| **Status** | Planning |
| **Priority** | Critical |
| **Estimated Time** | 2 hours |
| **Phase** | Phase 1: Combat Visuals & Basic Interaction |
| **Dependencies** | None (foundational feature) |

---

## 1. Purpose

### Why This Feature Exists

The Combat Grid is the foundational visual element for all tactical combat in Blood & Gold. Without a visible grid, players cannot make informed positioning decisions, which is core to the **Tactical Combat** design pillar. The grid transforms abstract tile coordinates into a concrete battlefield where flanking, cover, and chokepoints become visible and meaningful.

### What It Enables

- Players can see the battlefield layout before making moves
- Walkable vs blocked terrain is immediately obvious
- Foundation for all subsequent combat features (movement, selection, pathfinding)
- Visual grounding for the tactical CRPG experience

### Success Criteria

| Criterion | Measurement |
|-----------|-------------|
| Grid renders correctly | 12x12 tiles visible, centered on screen |
| Tiles are distinguishable | Walkable vs obstacle clearly different colors |
| Scale is appropriate | Grid fills 60-70% of screen width |
| Performance | No frame drops when rendering grid |

---

## 2. Design Pillar Alignment

| Pillar | How This Feature Supports It |
|--------|------------------------------|
| **Tactical Combat** | Grid makes positioning visible and strategic - players can see where to place units for flanking, cover, and chokepoints |
| **Build & Command** | Large grid (12x12) accommodates 8-12 friendly units + 15-20 enemies, enabling the "warband commander" fantasy |

---

## 3. How It Works

### Overview

The Combat Grid is a 12x12 square grid rendered using Godot's TileMapLayer node. Each tile is 64x64 pixels, making the full grid 768x768 pixels - approximately 40% of the screen width on a 1920x1080 display, centered horizontally with room for UI panels on the sides.

The grid uses a simple two-tile system for the prototype:
- **Walkable tiles**: Forest green (#4a6741) - units can move here
- **Obstacle tiles**: Dark gray (#2d3436) - blocks movement and line of sight

The grid is purely visual in this task - no interaction, no pathfinding, just rendering the battlefield so we can see it.

### Tile Types

| Tile Type | Color | Hex Code | Purpose |
|-----------|-------|----------|---------|
| Walkable | Forest Green | #4a6741 | Open terrain, units can occupy |
| Obstacle | Dark Gray | #2d3436 | Blocked terrain, impassable |

### Grid Specifications

| Property | Value | Rationale |
|----------|-------|-----------|
| Grid dimensions | 12 x 12 tiles | Fits 8-12 friendly + 15-20 enemies with room to maneuver |
| Tile size | 64 x 64 pixels | Large enough to fit unit sprites (56x56) with padding |
| Total grid size | 768 x 768 pixels | ~40% of 1920 width, leaves room for UI |
| Grid position | Centered horizontally, slightly above vertical center | Standard tactical game layout |

### Visual Layout

```
┌────────────────────────────────────────────────────────┐
│                    1920 x 1080 viewport                │
│  ┌─────────┐ ┌────────────────────────┐ ┌─────────┐   │
│  │         │ │                        │ │         │   │
│  │  Left   │ │    12x12 Combat Grid   │ │  Right  │   │
│  │  UI     │ │      (768 x 768)       │ │  UI     │   │
│  │  Panel  │ │                        │ │  Panel  │   │
│  │         │ │                        │ │         │   │
│  └─────────┘ └────────────────────────┘ └─────────┘   │
│                                                        │
│  ┌────────────────────────────────────────────────┐   │
│  │              Bottom UI Panel                    │   │
│  └────────────────────────────────────────────────┘   │
└────────────────────────────────────────────────────────┘
```

---

## 4. User Interaction

### This Task

**No user interaction in Task 1.1** - this is purely visual rendering. Interaction comes in later tasks:
- Task 1.4: Click-to-select units
- Task 1.5: Click-to-move with path preview

### Visual Feedback (This Task)

| Element | Feedback |
|---------|----------|
| Grid loads | 12x12 tiles appear centered on screen |
| Tile distinction | Walkable tiles clearly different from obstacles |

### Future Interaction (Not This Task)

- Hover over tile: Highlight effect (Task 1.5)
- Click tile: Selection or movement (Tasks 1.4-1.5)
- Valid move tiles: Green overlay when unit selected (Task 1.5)

---

## 5. Visual Design

### Tile Appearance

**Walkable Tile:**
```
┌──────────────────┐
│                  │
│   Forest Green   │
│    #4a6741       │
│                  │
│  64x64 pixels    │
│                  │
└──────────────────┘
```
- Solid color fill
- Subtle 1px darker border (#3d5636) for grid line visibility
- No texture (prototype placeholder)

**Obstacle Tile:**
```
┌──────────────────┐
│                  │
│    Dark Gray     │
│    #2d3436       │
│                  │
│  64x64 pixels    │
│                  │
└──────────────────┘
```
- Solid color fill
- Same 1px border style
- Visually "heavier" than walkable

### Color Palette

| Element | Color | Hex | Usage |
|---------|-------|-----|-------|
| Walkable tile fill | Forest Green | #4a6741 | Main walkable area |
| Walkable tile border | Dark Green | #3d5636 | Grid lines |
| Obstacle tile fill | Dark Gray | #2d3436 | Blocked terrain |
| Obstacle tile border | Darker Gray | #1a1a2e | Grid lines |
| Background | Near Black | #0d1117 | Behind grid |

### Grid Line Visibility

Grid lines should be visible but subtle:
- 1px width
- Slightly darker than tile fill
- Creates clear tile boundaries without dominating visually

---

## 6. Technical Implementation

### Scene Structure

```
CombatGrid.tscn
├── CombatGrid (Node2D) [root]
│   ├── TileMapLayer (TileMapLayer)
│   │   └── Uses TileSet with 2 tiles (walkable, obstacle)
│   └── GridBackground (ColorRect) [optional, for testing]
```

### Node Details

| Node | Type | Purpose |
|------|------|---------|
| CombatGrid | Node2D | Root node, handles positioning and script |
| TileMapLayer | TileMapLayer | Renders the 12x12 grid using tileset |
| GridBackground | ColorRect | Optional background behind grid (for contrast) |

### Script Responsibilities

**combat_grid.gd**
```gdscript
extends Node2D
class_name CombatGrid

# Grid configuration
const GRID_WIDTH: int = 12
const GRID_HEIGHT: int = 12
const TILE_SIZE: int = 64

# Tile IDs in tileset
const TILE_WALKABLE: int = 0
const TILE_OBSTACLE: int = 1

@onready var tile_map: TileMapLayer = $TileMapLayer

func _ready() -> void:
    _center_grid()
    _generate_default_grid()

func _center_grid() -> void:
    # Center the grid in viewport
    var viewport_size = get_viewport_rect().size
    var grid_pixel_size = Vector2(GRID_WIDTH * TILE_SIZE, GRID_HEIGHT * TILE_SIZE)
    position = (viewport_size - grid_pixel_size) / 2

func _generate_default_grid() -> void:
    # Fill with walkable tiles, add some obstacles for testing
    for x in range(GRID_WIDTH):
        for y in range(GRID_HEIGHT):
            tile_map.set_cell(Vector2i(x, y), 0, Vector2i(0, 0))  # Walkable

    # Add test obstacles
    _set_obstacle(Vector2i(5, 5))
    _set_obstacle(Vector2i(5, 6))
    _set_obstacle(Vector2i(6, 5))

func _set_obstacle(coords: Vector2i) -> void:
    tile_map.set_cell(coords, 0, Vector2i(1, 0))  # Obstacle tile

# Public API for future tasks
func get_tile_type(coords: Vector2i) -> int:
    var tile_data = tile_map.get_cell_atlas_coords(coords)
    return tile_data.x  # 0 = walkable, 1 = obstacle

func is_walkable(coords: Vector2i) -> bool:
    return get_tile_type(coords) == TILE_WALKABLE

func world_to_grid(world_pos: Vector2) -> Vector2i:
    var local_pos = world_pos - position
    return Vector2i(int(local_pos.x / TILE_SIZE), int(local_pos.y / TILE_SIZE))

func grid_to_world(grid_coords: Vector2i) -> Vector2:
    return position + Vector2(grid_coords.x * TILE_SIZE + TILE_SIZE / 2,
                               grid_coords.y * TILE_SIZE + TILE_SIZE / 2)
```

### TileSet Setup

Create a simple TileSet with two tiles:

1. **Create tileset resource** (`resources/tilesets/combat_tileset.tres`)
2. **Add tile source** (Atlas or individual tiles)
3. **Define tiles:**
   - Tile 0: Walkable (64x64, forest green)
   - Tile 1: Obstacle (64x64, dark gray)

**Option A: Programmatic Tiles (Simpler for Prototype)**
```gdscript
# In _ready(), create simple colored textures
func _create_tile_textures() -> void:
    var walkable_image = Image.create(TILE_SIZE, TILE_SIZE, false, Image.FORMAT_RGBA8)
    walkable_image.fill(Color("#4a6741"))
    # Add border
    for i in range(TILE_SIZE):
        walkable_image.set_pixel(i, 0, Color("#3d5636"))
        walkable_image.set_pixel(i, TILE_SIZE-1, Color("#3d5636"))
        walkable_image.set_pixel(0, i, Color("#3d5636"))
        walkable_image.set_pixel(TILE_SIZE-1, i, Color("#3d5636"))
    # Convert to texture and apply to tileset
```

**Option B: Pre-made Tile Images (Recommended)**
- Create `assets/sprites/tiles/tile_walkable.png` (64x64)
- Create `assets/sprites/tiles/tile_obstacle.png` (64x64)
- Import into TileSet in Godot editor

### Integration Points

| System | Integration |
|--------|-------------|
| Unit placement (Task 1.2) | `grid_to_world()` converts grid coords to world position |
| Click detection (Task 1.4) | `world_to_grid()` converts click position to grid coords |
| Pathfinding (Task 1.5) | `is_walkable()` provides obstacle data |
| Combat maps (Task 2.16-18) | Different map scenes inherit/configure grid |

### Signals (For Future Use)

```gdscript
signal tile_clicked(coords: Vector2i)
signal tile_hovered(coords: Vector2i)
```

These aren't implemented in Task 1.1 but define the interface for later tasks.

---

## 7. File Structure

```
scenes/
└── combat/
    └── CombatGrid.tscn          # Grid scene

scripts/
└── combat/
    └── combat_grid.gd           # Grid logic

assets/
└── sprites/
    └── tiles/
        ├── tile_walkable.png    # 64x64 forest green
        └── tile_obstacle.png    # 64x64 dark gray

resources/
└── tilesets/
    └── combat_tileset.tres      # TileSet resource
```

---

## 8. Acceptance Criteria

| # | Criterion | Test Method |
|---|-----------|-------------|
| 1 | Grid renders 12x12 tiles | Count tiles visually, verify 144 total |
| 2 | Grid is centered horizontally | Measure equal margins on left/right |
| 3 | Grid is positioned appropriately vertically | Leaves room for bottom UI |
| 4 | Walkable tiles are forest green (#4a6741) | Color picker verification |
| 5 | Obstacle tiles are dark gray (#2d3436) | Color picker verification |
| 6 | Tiles are clearly distinguishable | Can easily tell walkable from obstacle |
| 7 | Grid fills ~60-70% of screen width | 768px / 1920px = 40% (adjust if needed) |
| 8 | Grid lines visible between tiles | 1px borders create clear grid |
| 9 | No visual artifacts or gaps | Tiles align perfectly |
| 10 | Script API works | `is_walkable()`, `world_to_grid()`, `grid_to_world()` return correct values |

---

## 9. Testing Checklist

### Functional Tests
- [ ] Grid appears when scene loads
- [ ] Correct number of tiles (12x12 = 144)
- [ ] Tiles render at correct size (64x64)
- [ ] Grid centered in viewport
- [ ] Walkable and obstacle tiles have correct colors

### Visual Tests
- [ ] No gaps between tiles
- [ ] No overlapping tiles
- [ ] Grid lines visible but subtle
- [ ] Colors match specification
- [ ] Grid doesn't extend beyond intended bounds

### API Tests
- [ ] `is_walkable(Vector2i(0,0))` returns true (walkable tile)
- [ ] `is_walkable(Vector2i(5,5))` returns false (obstacle tile)
- [ ] `world_to_grid()` converts correctly
- [ ] `grid_to_world()` returns tile center position

### Edge Cases
- [ ] Grid renders correctly at different window sizes (if window resized)
- [ ] Obstacle tiles block appropriately (for future pathfinding)

---

## 10. Implementation Notes

### Approach Rationale

**Why TileMapLayer over manual sprites?**
- Built-in optimization for grid rendering
- Easy to modify tiles programmatically
- Native support for tile-based operations
- Better performance with large grids

**Why square grid over hex?**
- Simpler implementation for prototype
- Clearer movement (4/8 directions intuitive)
- Matches XCOM/Fire Emblem feel from influences
- Can convert to hex in full production if desired

**Why 64x64 tiles?**
- Large enough for 56x56 unit sprites with padding
- Clean division of 768px grid (12 * 64 = 768)
- Standard power-of-two size for textures

### Gotchas to Watch

1. **TileMapLayer vs TileMap**: Godot 4.x uses TileMapLayer (not TileMap from 3.x)
2. **Tile coordinates**: TileMapLayer uses Vector2i, not Vector2
3. **Atlas coords**: When setting tiles, need source_id and atlas_coords
4. **Centering**: Remember to account for grid's top-left origin when centering

### Future Considerations

- **Different map sizes**: Task 2.17 uses 14x14 grid - may need configurable size
- **Terrain types**: Cover and high ground tiles added in Task 2.12
- **Tile highlighting**: Overlay system needed for Task 1.5 (movement range)

---

## 11. Definition of Done

- [ ] `CombatGrid.tscn` scene created and renders correctly
- [ ] `combat_grid.gd` script implements core functionality
- [ ] Placeholder tile images created (or programmatic tiles)
- [ ] TileSet configured with walkable and obstacle tiles
- [ ] Grid centered in 1920x1080 viewport
- [ ] All acceptance criteria pass
- [ ] Code follows GDScript style guidelines
- [ ] Ready for Task 1.2 (Unit Placeholder Sprites)

---

## 12. References

### From GDD
- **Grid size**: "12x12 typical" (Section 3: Combat System)
- **Tile interaction**: "Terrain affects movement" (Section 3: Interactions)
- **Scale**: "8-12 units vs 15-20 enemies" (Section 2: Critical Questions)

### From Roadmap
- **Task 1.1**: Combat Grid Display (Phase 1, Day 1, 2 hours)
- **Dependencies**: None - this is the foundation
- **Leads to**: Task 1.2 (Unit Placeholder Sprites)

### Godot Documentation
- [TileMapLayer](https://docs.godotengine.org/en/stable/classes/class_tilemaplayer.html)
- [TileSet](https://docs.godotengine.org/en/stable/classes/class_tileset.html)
- [Using TileMaps](https://docs.godotengine.org/en/stable/tutorials/2d/using_tilemaps.html)
